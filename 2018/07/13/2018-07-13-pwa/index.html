<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="K1ToSIqNDa" />
    
    <title>聊聊PWA | LEOFE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="Leo, 前端, Web, 生活心得, 前端开发" >
    <meta name="description" content="知识杂货店" >
    <link rel="manifest" href="/js/manifest.json">

    
    <link rel="alternative" href="/atom.xml" title="LEOFE" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="/favicon.ico" >
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123804638-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-123804638-1');
    </script>
</head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">LEOFE</span>
                    <span class="description">知识杂货店</span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/2018/07/13/2018-07-13-pwa/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/2018/07/13/2018-07-13-pwa/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/2018/07/13/2018-07-13-pwa/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/codeSnipe" target="_blank">Github</a>
                        |
                    
                        <a href="https://www.jianshu.com/u/e7ff8dafa3c3" target="_blank">简书</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        微信号
                        <span class="popover">
                            <img src="/img/wechat.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/leofe.jpg" alt="avatar" title="Leo" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章页 -->
<!-- 文章 -->
<article class="post article">
    <header class="text-center">
        <h3 class="post-title"><span>聊聊PWA</span></h3>
    </header>
    <p class="post-meta text-center">
        leo 发表于
        <time datetime="2018-07-12T16:00:00.000Z">2018-07-13</time>
    </p>
    <div class="post-content">
        <h3 id="PWA是什么"><a href="#PWA是什么" class="headerlink" title="PWA是什么"></a>PWA是什么</h3><p>人们追求了极限这么多年，怎么能达到像原生一样的应用机制呢？最大的区别莫不是在于是不是动态加载资源，大家都知道APP很多资源安装包都包括了，所以Web很难超越。突然，一群牛B的谷歌工程师相处了一个解决方案，然后他们就在2016年Google I/O大会上提出了一个Next Web Generation的概念，也就是所谓的PWA，全称Progressice Web Apps（渐进式的网页应用）,其实这不是一个单独的技术，而是一些技术的合计。它可以提供更好的缓存机制，可以提供更多的原生硬功功能，下面咱们一起走进PWA的时间去转转。</p>
<h3 id="PWA中主要技术点"><a href="#PWA中主要技术点" class="headerlink" title="PWA中主要技术点"></a>PWA中主要技术点</h3><p>PWA整体主要用到以下技术内容：</p>
<ul>
<li>Service Workers：主要用来控制缓存内容。</li>
<li>Fetch API：一种比XMLHttpRequest更底层的API，意在统一浏览器的各种fetch，，使他们表现的更为一致。Fetch API中还定义了Response和Request对象接口，借此我们可以更方便的操作HTTP请求和相应。</li>
<li>App Manifest：可以支持PC与M端的桌面安装图标，以及首页内容配置。</li>
<li>Push Notification：消息推送机制，包含Notification和Push API两部分组成，前者用于向用户展示通知，后者用于订阅推送消息。</li>
<li>Background-sync：可以存储断网时浏览器的请求，当下一次连上网时会发送请求。</li>
</ul>
<h3 id="PWA特点介绍"><a href="#PWA特点介绍" class="headerlink" title="PWA特点介绍"></a>PWA特点介绍</h3><p>PWA是一种可以在网页中呈现出让人惊讶的效果的方法，PWA具备以下几个特色：</p>
<ol>
<li>Reliable(可靠性)：系统始终会为用户呈现出来页面，即使网络环境很差甚至无网络。</li>
<li>Fast(快速)：能够提供快速的用户相应，让用户拥有顺畅的操作体验。</li>
<li>Engaging(引人入胜的)：可以让web在设备上看起来像一个应用程序，提供沉浸式的用户体验。</li>
</ol>
<p>拥有了以上几点优势，让PWA也能够在在用户的屏幕上赢得一席之地。<br>但因为其缓存行，也会给不法分子提供更好的攻击途径，所以PWA在使用时，会有一些限制来保证用户网站能达到流程的用户体验的同时还保证用户的安全。<br>注意事项：</p>
<ol>
<li>PWA中Service-worker只能在https的域名中才可以注册，并对网站进行缓存，但谷歌为了提供开发环境，PWA也支持localhost或127.0.0.1本地域名注册。</li>
<li>Services-workers在缓存时也只能缓存对应的https得请求文件。</li>
</ol>
<h3 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h3><p>使用PWA缓存，最终要的是需要在页面中使用注册一个ServiceWorkers，并且此功能是单独的一个线程，区别于当前页面线程，所以在ServiceWorkers中是无法操作任何dom元素的。首先我们先了解一下ServiceWorkers的生命周期：<br>当页面首次安装ServiceWorkers时，会经历一下步骤：</p>
<ol>
<li>首先会在浏览器中注册一个进程，并安装注册的ServiceWorkers文件。</li>
<li>等待安装完成，在等待完成过程中，fetch，push等事件不会触发。</li>
<li>安装完成之后进入Activate状态，此时会可以使用ServiceWorkers中的完整功能。</li>
</ol>
<p>谷歌官方提供了动态示意图来更好的了解首次安装的过程，如下图所示：</p>
<p><iframe style="width:500px; height: 380px; border:none;" src="https://google-developers.appspot.com/web/fundamentals/primers/service-workers/lifecycle_24182cfd8a4a504321a9c5b5e62260f4.frame?hl=zh-tw"></iframe><br>来看看ServiceWorker兼容性:<br><img src="/assets/img/ServiceWorker.png" alt="ServiceWorker兼容性"><br>因为是比较新的技术，所以现在只能兼容到比较主流的浏览器，所以在注册时我们需要进行向下兼容。<br>PWA的功能导致会出现很多安全隐患，所以只能在localhost或者https的环境下才可被注册，所以接下来的demo，我采用一个vue的单页面应用来介绍，demo可以直接从我的github上下载来直接运行查看。<br>我们先准备一个html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt; </span><br><span class="line">    &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;/&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot; /&gt;</span><br><span class="line">    &lt;title&gt;SP1A&lt;/title&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们先来注册一下ServiceWorker:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">        if(&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">            navigator.serviceWorker.register(&apos;/sw.js?&apos;+new Date().getTime(),&#123;scope: &apos;/&apos;&#125;)</span><br><span class="line">            .then(reg =&gt; &#123;</span><br><span class="line">                console.log(&apos;Server worker registered!&apos;);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(err =&gt; &#123;</span><br><span class="line">                console.log(&apos;Server worker registered Fail!&apos;, err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们采用了在body尾注册ServiceWorder，在此位置加载不会阻止Dom渲染以及css加载的渲染，注册过程中我们已经做了向下兼容，当系统支持serviceWorder时才会注册，否则直接跳过。<br>具体来看我们注册了一个叫“sw.js”的文件，此文件为ServiceWorker的主文件。</p>
<p>sw.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//监听</span><br><span class="line">var filesToCache = [</span><br><span class="line">    &apos;/app.js&apos;</span><br><span class="line">]</span><br><span class="line">console.log(self);</span><br><span class="line">self.addEventListener(&apos;install&apos;, function(e) &#123;</span><br><span class="line">     </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>ServiceWorker本身,并非window本身,来看下打印出来的self具体为何物：<br><img src="/assets/img/sw-self.png" alt="Server-Worker中的self对象内容"><br>ServiceWorker在浏览器注册时，会开启单独线程，并行与浏览器的进程，ServiceWorker中self指向的是ServiceWorker的对象，所以在ServiceWorker中是无法操作DOM对象，只能操作ServiceWorker的接口API，ServiceWorker已经注册成功。<br><img src="/assets/img/waitUntil.png" alt="未使用waitUntil控制的SerivceWorker"></p>
<p>在ServiceWorker进入activate（激活）状态前，我们可以提前缓存一些已知文件，来达到更好的效果，这时候我们可以使用waitUntil函数。</p>
<h4 id="waitUntil"><a href="#waitUntil" class="headerlink" title="waitUntil"></a>waitUntil</h4><p>当ServiceWorker注册成功之后，并且在进行拦截之前，我们想提前缓存一部分已知的确定文件，此时，我们可以使用waitUntil函数，它可以使ServiceWorker无法直接进入到生命中期中的activite（激活）状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var cacheName=&quot;testcache&quot;;</span><br><span class="line">var filesToCache = [</span><br><span class="line">    &apos;/app.js&apos;</span><br><span class="line">]</span><br><span class="line">self.addEventListener(&apos;install&apos;, function(e) &#123;</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.open(cacheName).then(function(cache) &#123;</span><br><span class="line">            return cache.addAll(filesToCache);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们成功的在ServiceWorker第一次激活前创建了一个名为“testcache”的缓存数据，并且缓存了app.js.<br><img src="/assets/img/cache.png" alt="第一次加载时已经成功缓存了app.js"></p>
<p>激活之后请求的文件我们还需要继续缓存，接下来我们借助Fetch来进行后续的文件缓存工作。<br>来看看Fetch兼容性，基本也是最新浏览器的兼容程度，不用担心ServiceWorker注册后Fetch不兼容问题：<br><img src="/assets/img/fetch.png" alt="fetch兼容性"></p>
<h3 id="fetch功能"><a href="#fetch功能" class="headerlink" title="fetch功能"></a>fetch功能</h3><p>Fetch提供了一个获取资源的接口，任何使用过XMLHttpRequest的人都能轻松上手，但新的API提供了更强大和灵活的功能集，此处我们就不过多介绍Fetch功能，我们主要来看Fetch如何与ServiceWorker结合工作。<br>Fetch可以拦截任何形式的请求，所以我们可以在拦截到请求的时候进行判断，如果缓存中存在，可以不需要去请求服务器，如果不存在则去请求服务器，并进行缓存，以备下次使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;fetch&apos;, function(e) &#123;</span><br><span class="line">    e.respondWith(</span><br><span class="line">        //首先我们把拦截到的请求与cache中的资源做对比</span><br><span class="line">        caches.match(e.request)</span><br><span class="line">        .then(function(response)&#123;</span><br><span class="line">            //如果存在则直接返回缓存</span><br><span class="line">            if(response) &#123;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果不存在，我们会通过fetch来请求新的资源。</span><br><span class="line">            var fetchRequest = e.request.clone();</span><br><span class="line">            return fetch(fetchRequest)</span><br><span class="line">            .then(                </span><br><span class="line">                response =&gt; &#123;</span><br><span class="line">                    //请求接口报错时直接返回，不进行缓存</span><br><span class="line">                    if(!response || response.status != 200) &#123;</span><br><span class="line">                        console.log(&apos;%c因为错误不缓存：&apos;,&apos;color: green&apos;,e.request.url);</span><br><span class="line">                        return response;</span><br><span class="line">                    &#125;</span><br><span class="line">                    var responseToCache = response.clone();</span><br><span class="line">                    caches.open(cacheName)</span><br><span class="line">                    .then(function(cache) &#123;</span><br><span class="line">                        cache.put(e.request, responseToCache);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    return response;     </span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Fetch函数会拦截所有注册页面中的请求，并且针对请求来判断是否在缓存中，如果存在则可以直接返回缓存内容，无需请求，如果不存在从服务器请求。<br>值得注意的一点是：response与request都是单次对象，如果使用了就会消失，所以我们在使用之前要进行clone，才能更好的进行下面的工作。</p>
<h3 id="更新Service"><a href="#更新Service" class="headerlink" title="更新Service"></a>更新Service</h3><p>上面说了如何进行简单的PWA配置，接下来我们来简单聊聊更重要的环节，如何进行更新。<br>我们先看看，第二次打开页面进行注册时，整个Service Workerde运行过程：</p>
<p><iframe style="width:500px; height: 380px; border:none;" src="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle_e9ff0ea6f90a329d73a9d3c1ca6bd7a2.frame?hl=zh-cn"></iframe><br>我们需要在waitUntil中添加一个跳过等待的方法，否则新的sw会永远处于等待状态，如下图。<br><img src="/assets/img/noskip.png" alt="fetch兼容性"><br>针对此情况，我们在install周期时进行如下调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(e) &#123;</span><br><span class="line">    console.log(&apos;Service Worker installed&apos;);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.open(cacheName).then(function(cache) &#123;</span><br><span class="line">            cache.addAll(filesToCache);</span><br><span class="line">            //跳过等待</span><br><span class="line">            self.skipWaiting();</span><br><span class="line">            return ;</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>接下来，新注册的ServiceWorker使用的缓存名字换成了新的名字，激活之后从列表中查找，如果没有回删除掉其他的重新创建新的，我们需要把self的作用域提升到新的ServiceWorker中，使用self.clients.claim()即可做到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;activate&apos;, function(e) &#123;</span><br><span class="line">    console.log(&apos;Service Worker Activate&apos;);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        Promise.all([</span><br><span class="line">            self.clients.claim(),</span><br><span class="line">            caches.keys().then(function(cacheList) &#123;</span><br><span class="line">                return Promise.all(</span><br><span class="line">                    cacheList.map(function(cn) &#123;</span><br><span class="line">                        if(cn !== cacheName) &#123;</span><br><span class="line">                            return caches.delete(cn);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>好了，我们初步了解了一下如何通过Service Worker建立缓存机制，并且也了解了更新缓存的简单方法。如对PWA感兴趣，可以持续关注我，后续会针对ServiceWorker进行扩展的讲解。</p>
<p>参考资料：</p>
<ul>
<li>PWA：<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank">https://developers.google.com/web/progressive-web-apps/</a></li>
<li>Service Worker：<a href="https://www.w3.org/TR/service-workers/" target="_blank">https://www.w3.org/TR/service-workers/</a></li>
<li>Fetch：<a href="https://w3c.github.io/manifest/" target="_blank">https://w3c.github.io/manifest/</a></li>
<li>APP Manifest：<a href="https://w3c.github.io/manifest/" target="_blank">https://w3c.github.io/manifest/</a></li>
<li>Push API：<a href="https://www.w3.org/TR/push-api/" target="_blank">https://www.w3.org/TR/push-api/</a></li>
<li>Background Sync：<a href="https://developers.google.com/web/updates/2015/12/background-sync" target="_blank">https://developers.google.com/web/updates/2015/12/background-sync</a></li>
</ul>

    </div>
    <p class="post-meta">
        <span class="post-cat">分类：
            <a class="cat-link" href="/categories/技术仓库/">技术仓库</a>
        </span>
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/PWA/" title="PWA">PWA</a>
    

        </span>
    </p>
</article>
<!-- 分享按钮 -->

  <div class="article-share clearfix text-center">
    <div class="share-area">
      <span class="share-txt">分享到：</span>
      <a href="javascript: window.open('http://service.weibo.com/share/share.php?url=' + encodeURIComponent(location.href) + '&title=' + document.title + '&language=zh_cn');" class="share-icon weibo"></a>
      <a href="javascript: alert('请复制链接到微信并发送');" class="share-icon wechat"></a>
      <a href="javascript: window.open('http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodeURIComponent(location.href) + '&title=' + document.title);" class="share-icon qqzone"></a>
      <a href="javascript: window.open('http://connect.qq.com/widget/shareqq/index.html?url=' + encodeURIComponent(location.href) + '&desc=Jelon个人博客&title=' + document.title + '&callback=' + encodeURIComponent(location.href));" class="share-icon qq"></a>
      <a href="javascript: window.open('http://shuo.douban.com/!service/share?href=' + encodeURIComponent(location.href) + '&name=' + document.title + '&text=' + document.title);" class="share-icon douban"></a>
    </div>
  </div>


<!-- 上一篇/下一篇 -->

<div class="article-nav clearfix">
    
    <span class="prev fl">
        上一篇<br >
        <a href="/2018/07/13/2018-08-18-resource-hints/">
            
                谈谈你不知道的《Resource Hints》
            
        </a>
    </span>
    

    
    <span class="next fr">
        下一篇<br >
        <a href="/2018/06/17/2018-06-17-git/">
            
                Git删除与恢复branch
            
        </a>
    </span>
    
</div>

<!-- 文章评论 -->

  <script src="/js/comment.js"></script>
  <div id="comments" class="comment">
    <!--
    <div class="sign-bar">
      GitHub 已登录!
      <span class="sign-link">登出</span>
    </div>
    <section class="box">
      <div class="com-avatar"><img src="/img/jelon.jpg" alt="avatar"></div>
      <div class="com-text">
        <div class="main">
          <textarea class="text-area-edited show" placeholder="欢迎评论！"></textarea>
          <div class="text-area-preview"></div>
        </div>
        <div class="switch">
          <div class="switch-item on">编辑</div>
          <div class="switch-item">预览</div>
        </div>
        <div class="button">提交</div>
      </div>
    </section>
    <section class="tips">注：评论支持 markdown 语法！</section>
    <section class="list-wrap">
      <ul class="list">
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">张德龙</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like liked">已赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">333333</div>
          </div>
        </li>
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">刘德华</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like">点赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">vvvvv</div>
          </div>
        </li>
      </ul>
      <div class="page-nav">
        <a href="javascript: void(0);" class="item">1</a>
        <a href="javascript: void(0);" class="item">2</a>
        <a href="javascript: void(0);" class="item current">3</a>
      </div>
    </section>
    -->
  </div>
  <script>
  JELON.Comment({
    container: 'comments',
    label: '2018-07-13-pwa',
    owner: 'leofe',
    repo: 'leofe.github.io',
    clientId: 'c5f228f544d943181242',
    clientSecret: 'df3363ed741c2d6768baacf3cd0055474f3432d7'
  });
  </script>


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/技术仓库/">技术仓库</a>
        <span class="badge">(15)</span>
    </li>
    
    <li>
        <a href="/categories/书单/">书单</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/react/" title="react">react (3)</a>
  
    <a class="tag-item" href="/tags/book/" title="book">book (1)</a>
  
    <a class="tag-item" href="/tags/js/" title="js">js (3)</a>
  
    <a class="tag-item" href="/tags/nodeJS/" title="nodeJS">nodeJS (1)</a>
  
    <a class="tag-item" href="/tags/WebGL/" title="WebGL">WebGL (5)</a>
  
    <a class="tag-item" href="/tags/Git/" title="Git">Git (1)</a>
  
    <a class="tag-item" href="/tags/PWA/" title="PWA">PWA (1)</a>
  
    <a class="tag-item" href="/tags/技术/" title="技术">技术 (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2018
    

    <a href="/">Leo's Knowledge Store</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
<script src="/js/preload.js"></script>

	<script type="text/javascript">
		window.addEventListener('load', function () {
			if('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/sw.js?'+new Date().getTime(),{scope: '/'})
				.then(reg => {
					console.log('Server worker registered!');
				})
				.catch(err => {
					console.log('Server worker registered Fail!', err)
				})
			}
		});    
	</script>
</body>
</html>