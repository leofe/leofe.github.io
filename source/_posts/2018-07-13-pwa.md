---
title: PWA初体验
date: 2018-07-13
author: leo
tags: PWA
categories:
    - 技术仓库
thumbnail: 技术
blogexcerpt: 怎么能更好的让前端代码看起来更像APP呢，性能更接近APP呢，那肯定是不需要先加载内容在去执行内容，APP原生的框架代码都在本地，性能一定会快过需要首先加载资源的H5，如果我们也可以把资源都安装在本地的话呢？
---

### 当前前端背景
几年前，用H5开发APP很流行，除了众多框架来辅助，如phoneGap，appCan等，本质上框架帮忙创建了一个Webview，并且把写的h5运行在一个内嵌WebView浏览器中，这种曾经风靡一时的开发方式叫Hybird App，混合开发。但因为其性能问题，逐渐的被冷落,接下来众多大神开始想法把js直接通过一个框架转化成java或者oc，让一套H5代码直接运行在多端，最火的可能就是基于React的React Native。这是一个神一样的框架，的确让我们向大前端前进了一大步。但这依旧离不开其他代码，只不过rn帮忙将JS转换成了对应的系统代码而已。怎么能更好的让前端代码看起来更像APP呢，性能更接近APP呢，那肯定是不需要先加载内容在去执行内容，APP原生的框架代码都在本地，性能一定会快过需要首先加载资源的H5，如果我们也可以把资源都安装在本地的话呢？那岂不是与APP是一样的了？只有数据请求时才会去加载数据，否则与网速是不想管的。
恰逢2017年CMTC大会，谷歌的开发者发布了名为Progressive Web App(渐进式的网页程序，本文以下内容均简称为PWA)，终于让大家思考的成为了可能。

### PWA特点介绍
PWA是一种可以在网页中呈现出让人惊讶的效果的方法，PWA具备以下几个特色：
1. Reliable(可靠性)：系统始终会为用户呈现出来页面，即使网络环境很差甚至无网络。
2. Fast(快速)：能够提供快速的用户相应，让用户拥有顺畅的操作体验。
3. Engaging(引人入胜的)：可以让web在设备上看起来像一个应用程序，提供沉浸式的用户体验。

拥有了以上几点优势，让PWA也能够在在用户的屏幕上赢得一席之地。
但因为其缓存行，也会给不法分子提供更好的攻击途径，所以PWA在使用时，会有一些限制来保证用户网站能达到流程的用户体验的同时还保证用户的安全。
注意事项：
1. PWA中Service-worker只能在https的域名中才可以注册，并对网站进行缓存，但谷歌为了提供开发环境，PWA也支持localhost或127.0.0.1本地域名注册。
2. Services-workers在缓存时也只能缓存对应的https得请求文件。

### PWA中主要技术点
PWA整体主要用到以下技术内容：
- Service Workers：主要用来控制缓存内容。
- Fetch：主要用于拦截各种请求，并且判断是否可以使用Service Workers缓存。

### 先编写一个简单的ServiceWorker
使用PWA缓存，最终要的是需要在页面中使用注册一个ServiceWorkers，并且此功能是单独的一个线程，区别于当前页面线程，所以在ServiceWorkers中是无法操作任何dom元素的。首先我们先了解一下ServiceWorkers的生命周期：
当页面首次安装ServiceWorkers时，会经历一下步骤：
1. 首先会在浏览器中注册一个进程，并安装注册的ServiceWorkers文件。
2. 等待安装完成，在等待完成过程中，fetch，push等事件不会触发。
3. 安装完成之后进入Activate状态，此时会可以使用ServiceWorkers中的完整功能。

谷歌官方提供了动态示意图来更好的了解首次安装的过程，如下图所示：

<iframe style='width:500px; height: 380px; border:none;' src="https://google-developers.appspot.com/web/fundamentals/primers/service-workers/lifecycle_24182cfd8a4a504321a9c5b5e62260f4.frame?hl=zh-tw"></iframe>

我们先准备一个html
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" /> 
    <meta content="telephone=no" name="format-detection"/>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <title>SP1A</title> 
</head> 
  <body>
    <div id="app"></div>    
  </body>
</html>
```
我们先来注册一下ServiceWorker:
```
 <script type="text/javascript">
    window.addEventListener('load', function () {
        if('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js?'+new Date().getTime(),{scope: '/'})
            .then(reg => {
                console.log('Server worker registered!');
            })
            .catch(err => {
                console.log('Server worker registered Fail!', err)
            })
        }
    });   
</script>
```
我们采用了在body尾注册ServiceWorder，在此位置加载不会阻止Dom渲染以及css加载的渲染，注册过程中我们已经做了向下兼容，当系统支持serviceWorder时才会注册，否则直接跳过。
具体来看我们注册了一个叫“sw.js”的文件，此文件为ServiceWorker的主文件。

sw.js文件
```
//监听
var filesToCache = [
    '/app.js'
]
console.log(self);
self.addEventListener('install', function(e) {
     e.waitUntil(
         caches.open('testcache').then(function(cache) {
             return cache.addAll(filesToCache);
         })
    )
})
```
ServiceWorker在浏览器注册时，会开启单独线程，并行与浏览器的进程，所以在ServiceWorker中，无法针对Dom进行操作，并且ServiceWorker中self指向ServiceWorker本身,并非window本身,来看下打印出来的self具体为何物：
<img src='/assets/img/sw-self.png' alt="Server-Worker中的self对象内容" width="400px">






### fetch功能




<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank">更多的PWA内容可前往谷歌官网</a>

