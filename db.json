{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-xups/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","path":"img/jelon.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","path":"img/scrolltoparrow.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/share.png","path":"img/share.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","path":"img/wechat_jelon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/url.png","path":"img/url.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","path":"img/wechat_mp.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/html5.js","path":"js/html5.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/comment.js","path":"js/comment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/no_found.png","path":"img/no_found.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","path":"img/unsigned_avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.jpg","path":"img/wechat_pay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","path":"img/lab/banner.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","path":"img/thumbnail/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","path":"img/thumbnail/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","path":"img/thumbnail/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","path":"img/thumbnail/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","path":"img/thumbnail/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","path":"img/thumbnail/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","path":"img/thumbnail/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","path":"img/thumbnail/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","path":"css/fonts/icomoon/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/leofe.jpg","path":"img/leofe.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","path":"img/thumbnail/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","path":"img/thumbnail/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","path":"css/fonts/homizio-nova/italic.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","path":"css/fonts/homizio-nova/italic.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","path":"css/fonts/homizio-nova/light.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","path":"css/fonts/homizio-nova/light_italic.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","path":"css/fonts/homizio-nova/light_italic.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","path":"css/fonts/homizio-nova/regular.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","path":"css/fonts/icomoon/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","path":"css/fonts/icomoon/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","path":"css/fonts/icomoon/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","path":"css/fonts/homizio-nova/light.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","path":"css/fonts/homizio-nova/regular.ttf","modified":0,"renderable":1},{"_id":"source/assets/img/10-2.jpg","path":"assets/img/10-2.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/cry.jpg","path":"assets/img/cry.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/right.jpg","path":"assets/img/right.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/table.png","path":"assets/img/table.png","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei10-4.png","path":"assets/img/yanglei10-4.png","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei10-3.jpg","path":"assets/img/yanglei10-3.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei12-1.jpg","path":"assets/img/yanglei12-1.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei11-1.jpg","path":"assets/img/yanglei11-1.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei6.jpg","path":"assets/img/yanglei6.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei7-bug2.jpg","path":"assets/img/yanglei7-bug2.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei8-2.jpg","path":"assets/img/yanglei8-2.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei5.jpg","path":"assets/img/yanglei5.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei8.jpg","path":"assets/img/yanglei8.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei7-bug1.png","path":"assets/img/yanglei7-bug1.png","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei8-1.png","path":"assets/img/yanglei8-1.png","modified":1,"renderable":0},{"_id":"source/assets/img/10-2.png","path":"assets/img/10-2.png","modified":1,"renderable":0},{"_id":"source/assets/img/gzh.png","path":"assets/img/gzh.png","modified":1,"renderable":0},{"_id":"source/assets/img/bolang1.gif","path":"assets/img/bolang1.gif","modified":1,"renderable":0},{"_id":"source/assets/img/bolang2.gif","path":"assets/img/bolang2.gif","modified":1,"renderable":0},{"_id":"source/assets/img/bolang3.gif","path":"assets/img/bolang3.gif","modified":1,"renderable":0},{"_id":"source/assets/img/bolang4.gif","path":"assets/img/bolang4.gif","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei10-1.gif","path":"assets/img/yanglei10-1.gif","modified":1,"renderable":0},{"_id":"source/assets/img/yanglei10-2.gif","path":"assets/img/yanglei10-2.gif","modified":1,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-xups/.DS_Store","hash":"0f9c0b22b8f97f467df8b2a7c0296adfe8b7aa2e","modified":1529220876192},{"_id":"themes/hexo-theme-xups/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1528335210567},{"_id":"themes/hexo-theme-xups/README.md","hash":"71f6ebf5e9b6689f81e03525335b071d7a954944","modified":1528335210568},{"_id":"themes/hexo-theme-xups/_config.yml","hash":"5773a1ec9205c7f4e37b8e0b0621bbbb21daa173","modified":1529219495013},{"_id":"source/.DS_Store","hash":"40d3908bc3beee130ff52f087ec0ab7405f1f809","modified":1529221464532},{"_id":"source/_posts/.DS_Store","hash":"a3b9754b0cb3cafc1b57c32e46f0972d43554656","modified":1529211965742},{"_id":"source/_posts/2018-01-09-yanglei1.markdown","hash":"dfd47ef245f93c49f6a4864907e6d655de540801","modified":1529212125117},{"_id":"source/_posts/2018-01-09-yanglei2.markdown","hash":"a63165185bd28cba3ffcc0b200ea52043179f16a","modified":1529212129281},{"_id":"source/_posts/2018-01-16-yanglei3.markdown","hash":"35c9d120f0bd14bd31265c1d7df3a394ad2d226c","modified":1529221033187},{"_id":"source/_posts/2018-01-17-yanglei4.md","hash":"ecf874f8e76f22554f9ffa9c2dd99319adf3a021","modified":1529221070156},{"_id":"source/_posts/2018-01-23-yanglei5.md","hash":"56961b33d4e289cc852dc000e0b982a18a6cab06","modified":1529221199518},{"_id":"source/_posts/2018-01-24-yanglei6.md","hash":"d8bc0616afcdccddc718c5c253dbe9bb831210a6","modified":1529221194026},{"_id":"source/_posts/2018-01-25-yanglei7.md","hash":"0c4a6a80a4919a97977c13b70f9aaef65a3aa249","modified":1529221184768},{"_id":"source/_posts/2018-02-05-yanglei8.md","hash":"2685f8cce96d6e23c4328cbb95e95d10996fe917","modified":1529221225172},{"_id":"source/_posts/2018-03-13-yanglei9.md","hash":"88f785c88c68481e14617852dd13432df4de1ad0","modified":1529221250647},{"_id":"source/_posts/2018-04-04-yanglei10.md","hash":"9a661c454d977d7bd336708d4e8eabce8b398498","modified":1529221273985},{"_id":"source/_posts/2018-04-13-yanglei11.md","hash":"411df4bde327fb8a3132dc48bd0a298d337c1d02","modified":1529221300753},{"_id":"source/_posts/2018-04-13-yanglei12.md","hash":"f0a6ac68c5804c0ebbd8548ae7a7337ce8a0baf9","modified":1529221322775},{"_id":"source/comment/index.md","hash":"7aa4e68e0b93e0120f5c04f7443737a63c3be04b","modified":1529211240314},{"_id":"source/about/index.md","hash":"412d256cac08818a734905b25131a2c67f81b656","modified":1529210231099},{"_id":"source/lab/index.md","hash":"67dfb6bc43414b499e8d4224f50e61dece8c4519","modified":1529210231099},{"_id":"themes/hexo-theme-xups/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1528335210561},{"_id":"themes/hexo-theme-xups/.git/config","hash":"8a1471fecafd7db6e89b53b16ca1e53294948ab0","modified":1528335210563},{"_id":"themes/hexo-theme-xups/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1528335026593},{"_id":"themes/hexo-theme-xups/.git/index","hash":"404daa403ef909de5880b7d53760335fd05e80ef","modified":1529215697899},{"_id":"themes/hexo-theme-xups/.git/packed-refs","hash":"7cb7610161ba874f7b5a32ef6dca8762b933493d","modified":1528335210559},{"_id":"themes/hexo-theme-xups/__scaffolds/draft.md","hash":"a7fd8b8488eb143616b8e2a64b4df4796a46749b","modified":1528335210568},{"_id":"themes/hexo-theme-xups/__scaffolds/page.md","hash":"f0af1cb10f27d859caa51c8e3704469d9ed842a6","modified":1528335210568},{"_id":"themes/hexo-theme-xups/__scaffolds/post.md","hash":"a7fd8b8488eb143616b8e2a64b4df4796a46749b","modified":1528335210568},{"_id":"themes/hexo-theme-xups/layout/archive.ejs","hash":"31abd4b39017d7edb46d39602869dd6960d0257d","modified":1529211213228},{"_id":"themes/hexo-theme-xups/layout/category.ejs","hash":"85318d660fae55d3163c7bedcb4024171e424b50","modified":1528335210576},{"_id":"themes/hexo-theme-xups/layout/index.ejs","hash":"14638cc02aa4c6a89525aafdd5ddab218716da60","modified":1528335210576},{"_id":"themes/hexo-theme-xups/layout/layout.ejs","hash":"6a9ca891687ce82bdece8180a916a758ced62780","modified":1528335210576},{"_id":"themes/hexo-theme-xups/layout/page.ejs","hash":"645f4dbe9430d26dbb851221aa55808870f41a9b","modified":1528335210576},{"_id":"themes/hexo-theme-xups/layout/post.ejs","hash":"b5e43e5408546ee142a060cc6253f3a4ea869174","modified":1529211192635},{"_id":"themes/hexo-theme-xups/layout/tag.ejs","hash":"0c04305b5f407c21a2ffeb2317e61b7f830eeeff","modified":1528335210577},{"_id":"themes/hexo-theme-xups/layout/tags.ejs","hash":"cbfc913dcc81ccca5cd3dbea743c6202a10cf6ef","modified":1528335210577},{"_id":"themes/hexo-theme-xups/source/.DS_Store","hash":"5290b91d601b7693a82257b35ea2d9be9635c5d7","modified":1529220849083},{"_id":"themes/hexo-theme-xups/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1528335026594},{"_id":"themes/hexo-theme-xups/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1528335026593},{"_id":"themes/hexo-theme-xups/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1528335026595},{"_id":"themes/hexo-theme-xups/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1528335026596},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1528335026596},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1528335026597},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1528335026594},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1528335026594},{"_id":"themes/hexo-theme-xups/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1528335026595},{"_id":"themes/hexo-theme-xups/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1528335026596},{"_id":"themes/hexo-theme-xups/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1528335026597},{"_id":"themes/hexo-theme-xups/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1528335026593},{"_id":"themes/hexo-theme-xups/.git/logs/HEAD","hash":"93d5b477481a5477f6806c7cf331297bbcf47701","modified":1528335210562},{"_id":"themes/hexo-theme-xups/__source/about/index.md","hash":"412d256cac08818a734905b25131a2c67f81b656","modified":1528335210569},{"_id":"themes/hexo-theme-xups/__source/comment/index.md","hash":"7aa4e68e0b93e0120f5c04f7443737a63c3be04b","modified":1528335210569},{"_id":"themes/hexo-theme-xups/__source/lab/index.md","hash":"67dfb6bc43414b499e8d4224f50e61dece8c4519","modified":1528335210569},{"_id":"themes/hexo-theme-xups/layout/_custom/about.ejs","hash":"1cb47f52f0b890ba7ca959b2cd0b40222858f213","modified":1528335210570},{"_id":"themes/hexo-theme-xups/layout/_custom/comment.ejs","hash":"60a7cd76bb21c7bc0ec4c39b9736c34251db34bf","modified":1529215179639},{"_id":"themes/hexo-theme-xups/layout/_custom/lab.ejs","hash":"c016ca3e32b72daa1897d7e2954c21f373b04327","modified":1528335210570},{"_id":"themes/hexo-theme-xups/layout/_partial/after-footer.ejs","hash":"914a1e80bd70ba029353fa7c4519667aa236b4fa","modified":1528335210571},{"_id":"themes/hexo-theme-xups/layout/_partial/archive-post.ejs","hash":"4bcede85147a8d8ccca7a2b3cf3a9422a99c2f1f","modified":1528335210571},{"_id":"themes/hexo-theme-xups/layout/_partial/archive.ejs","hash":"662ccb612a07b80628906ff1d3e4af8d48ad98c4","modified":1528335210571},{"_id":"themes/hexo-theme-xups/layout/_partial/article.ejs","hash":"7b60dd61d5697558acfc2f2cd29e88aba394e569","modified":1528335210572},{"_id":"themes/hexo-theme-xups/layout/_partial/baidu-analytics.ejs","hash":"4e423e13ace638931c44f268fe521300984149e7","modified":1528335210572},{"_id":"themes/hexo-theme-xups/layout/_partial/footer.ejs","hash":"103a1d24c54070ceae9fe427fd8f2471b2bebb6d","modified":1528335210572},{"_id":"themes/hexo-theme-xups/layout/_partial/head.ejs","hash":"40c0323bc182b5cf4cbfa35a4f813bf9c568c835","modified":1528335210572},{"_id":"themes/hexo-theme-xups/layout/_partial/header.ejs","hash":"f0f9088301ca47a297eb32e391c584355a3711c4","modified":1528335210572},{"_id":"themes/hexo-theme-xups/layout/_partial/sidebar.ejs","hash":"d044cbd121fc377d8d12196c22289d9b10d9cc89","modified":1528335210574},{"_id":"themes/hexo-theme-xups/layout/_widget/categorys.ejs","hash":"93b8aae666a11c759c98907a7f78594bca029280","modified":1528335210574},{"_id":"themes/hexo-theme-xups/layout/_widget/friend_links.ejs","hash":"3989e3d7afa49fd632250b555a639efcdca28f96","modified":1528335210575},{"_id":"themes/hexo-theme-xups/layout/_widget/tags.ejs","hash":"5feb9aaf13e606d687e9816325bf212ef110d46c","modified":1528335210575},{"_id":"themes/hexo-theme-xups/layout/_widget/weibo.ejs","hash":"db02c4b93932b5fe764ab018bb22a01f23b40d33","modified":1528335210575},{"_id":"themes/hexo-theme-xups/source/css/.DS_Store","hash":"7a2750dc6206c6f07303809521f5eb6654cfc3b3","modified":1528335210578},{"_id":"themes/hexo-theme-xups/source/css/_extend.styl","hash":"cf2b2e114d79a77c4e98771a8f80b00aa9d5078b","modified":1528335210579},{"_id":"themes/hexo-theme-xups/source/css/_markdown.styl","hash":"cce612ff67ad1d88a8cee1a5cfe3460f8f507e06","modified":1528335210579},{"_id":"themes/hexo-theme-xups/source/css/_variables.styl","hash":"0208156f550db42697f997fefade378f16c250ff","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/css/style.styl","hash":"d639ec5c6ee4751385f62287d759b832f07ad01d","modified":1528335210586},{"_id":"themes/hexo-theme-xups/source/img/.DS_Store","hash":"82b66b00e783303417397be706f02457fbcbbd22","modified":1529217031750},{"_id":"themes/hexo-theme-xups/source/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1528335210587},{"_id":"themes/hexo-theme-xups/source/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1528335210587},{"_id":"themes/hexo-theme-xups/source/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1528335210588},{"_id":"themes/hexo-theme-xups/source/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1528335210588},{"_id":"themes/hexo-theme-xups/source/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1528335210588},{"_id":"themes/hexo-theme-xups/source/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1528335210594},{"_id":"themes/hexo-theme-xups/source/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1528335210593},{"_id":"themes/hexo-theme-xups/source/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1528335210594},{"_id":"themes/hexo-theme-xups/source/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1528335210595},{"_id":"themes/hexo-theme-xups/source/js/comment.js","hash":"62a95a65453e42dad2b8813c616b1be451e1a577","modified":1528335210595},{"_id":"themes/hexo-theme-xups/source/js/main.js","hash":"457dc472d3a3aecfb57fdbe80d7d475c3ef5baf4","modified":1528335210595},{"_id":"themes/hexo-theme-xups/source/img/no_found.png","hash":"aa383a9a73b3468b6a77ea3e3676b3f9d6e6ef0d","modified":1528335210588},{"_id":"themes/hexo-theme-xups/source/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1528335210593},{"_id":"themes/hexo-theme-xups/source/img/wechat_pay.jpg","hash":"8b2c2ec6b3ac7d88ac73cd15cf1f23a2bb6a435d","modified":1529215883279},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-d1fa180862d82b4d592b36215a00c3f5c3d863a9.idx","hash":"0696f5a44cd11b878f50147075f3d114418faf4d","modified":1528335210545},{"_id":"themes/hexo-theme-xups/.git/refs/heads/master","hash":"e59e322bfc39aafa16e40c11a47f3131f04665bc","modified":1528335210562},{"_id":"themes/hexo-theme-xups/layout/_partial/post/category.ejs","hash":"c3fc5b276c66e5eb8caaae94e102f0f26150e112","modified":1528335210573},{"_id":"themes/hexo-theme-xups/layout/_partial/post/comment.ejs","hash":"fa9a1df7c6d1f49013ae77d1710bc124a6baecc0","modified":1529220293404},{"_id":"themes/hexo-theme-xups/layout/_partial/post/date.ejs","hash":"848f362936b3f21e067e2a0783efbdbdab338985","modified":1528335210573},{"_id":"themes/hexo-theme-xups/layout/_partial/post/gallery.ejs","hash":"967c57ae109f0ff35e326005f1d3408ab233fbbe","modified":1528335210573},{"_id":"themes/hexo-theme-xups/layout/_partial/post/nav.ejs","hash":"913216eaa215df6457fb4f67771cafc7574c2690","modified":1528335210573},{"_id":"themes/hexo-theme-xups/layout/_partial/post/share.ejs","hash":"c5100bd87020a3cfd0980144a7dc32aa2567c858","modified":1528335210574},{"_id":"themes/hexo-theme-xups/layout/_partial/post/tag.ejs","hash":"9828fcc52f7ace1436ffa5a5420506de0ab9e190","modified":1528335210574},{"_id":"themes/hexo-theme-xups/layout/_partial/post/title.ejs","hash":"bbdbc39e30776b6ac5a5f8d0d6220a75a644e45a","modified":1528335210574},{"_id":"themes/hexo-theme-xups/source/css/_base/font.styl","hash":"5a786cdb9de68297d26f8609a42c133f9035f940","modified":1528335210578},{"_id":"themes/hexo-theme-xups/source/css/_base/global.styl","hash":"46e85024409b655234ce00811da3f8600d1deaec","modified":1528335210578},{"_id":"themes/hexo-theme-xups/source/css/_base/normalize.styl","hash":"cbff0cb51c494e3ceba25f34eafd3127ff5266e9","modified":1528335210578},{"_id":"themes/hexo-theme-xups/source/css/_base/reset.styl","hash":"77f86b1fe8f6b8db337892876dc8aec08f6e30dc","modified":1528335210578},{"_id":"themes/hexo-theme-xups/source/css/_partial/.DS_Store","hash":"16121b987e7a7a6c89f78f512e6e63eea583e25a","modified":1528335210579},{"_id":"themes/hexo-theme-xups/source/css/_partial/article.styl","hash":"62258eaa64dde41a31b003cb8904cb04181ecb69","modified":1528335210579},{"_id":"themes/hexo-theme-xups/source/css/_partial/comment.styl","hash":"9be5683da5a466d64c9de62de0332ac50a3dfdeb","modified":1528335210579},{"_id":"themes/hexo-theme-xups/source/css/_partial/footer.styl","hash":"d1f54068da8544a514e13d2c08d39b42dac1edf3","modified":1528335210580},{"_id":"themes/hexo-theme-xups/source/css/_partial/header.styl","hash":"4d0ac2fa978ac22589cc2b2df62f7fb5721f595a","modified":1528335210580},{"_id":"themes/hexo-theme-xups/source/css/_partial/highlight.styl","hash":"cd53e73ddee5258f3d2f2eb11737436b29b51236","modified":1528335210580},{"_id":"themes/hexo-theme-xups/source/css/_partial/post.styl","hash":"80bfe9b69c48837915335c8215db4f869f841baa","modified":1528335210580},{"_id":"themes/hexo-theme-xups/source/css/_partial/responsive.styl","hash":"5fd085dadf3122f4cd5ae934492ea853a14e6180","modified":1528335210580},{"_id":"themes/hexo-theme-xups/source/css/_partial/searchform.styl","hash":"d2cad21d79b3a4a21dbc4a759c6cc3ae8d4a282f","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/css/_partial/sidebar.styl","hash":"3d0e8e39b85639d4d50ee692744c8562de431cd9","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/css/_partial/theme.styl","hash":"5d928942e4d8f88be30860452a491560c81aea02","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/css/fonts/.DS_Store","hash":"db2379b0a524b084530079a6a32ba976f2892009","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1528335210587},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1528335210589},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1528335210589},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1528335210590},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1528335210591},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1528335210591},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1528335210591},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1528335210592},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1528335210592},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528335210586},{"_id":"themes/hexo-theme-xups/source/img/leofe.jpg","hash":"d42f333fcfb5a8fb9c8eb9df1278fbb3cbeb2a58","modified":1529217011434},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1528335210590},{"_id":"themes/hexo-theme-xups/source/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1528335210590},{"_id":"themes/hexo-theme-xups/.git/logs/refs/heads/master","hash":"93d5b477481a5477f6806c7cf331297bbcf47701","modified":1528335210562},{"_id":"themes/hexo-theme-xups/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1528335210561},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/.DS_Store","hash":"94c491df2256ef547252eed029a8bfb2961da5fe","modified":1528335210581},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1528335210582},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1528335210583},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1528335210583},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1528335210584},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1528335210585},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1528335210585},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1528335210586},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.svg","hash":"90f9bbc99d84f36ffa811543bed70a2d79f363b7","modified":1528335210586},{"_id":"themes/hexo-theme-xups/source/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1528335210586},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1528335210584},{"_id":"themes/hexo-theme-xups/source/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1528335210585},{"_id":"themes/hexo-theme-xups/.git/logs/refs/remotes/origin/HEAD","hash":"93d5b477481a5477f6806c7cf331297bbcf47701","modified":1528335210560},{"_id":"themes/hexo-theme-xups/xups.png","hash":"22f1fc32dea794370b4e791b885c2afb03c886c6","modified":1528335210603},{"_id":"themes/hexo-theme-xups/.git/objects/pack/pack-d1fa180862d82b4d592b36215a00c3f5c3d863a9.pack","hash":"6ff259fd3ea6bf877ef69a6840d245a64a68645a","modified":1528335210545},{"_id":"public/comment/index.html","hash":"67e19bfc73e462613e1e4ef8c42f6d1b7c25776d","modified":1529221489080},{"_id":"public/about/index.html","hash":"f7241b5572dd7fa8657e4ce920273e90c1174f70","modified":1529221489080},{"_id":"public/lab/index.html","hash":"fb5c55841dc6acb57321ed7061e99a57bf48136f","modified":1529221489080},{"_id":"public/2018/06/17/2018-01-25-yanglei7/index.html","hash":"49c4f4283a60b467e20389e6571fe981e1c9481e","modified":1529221489080},{"_id":"public/2018/06/17/2018-01-23-yanglei5/index.html","hash":"678a152c9da44ad1950a53e76e0bec074ea45072","modified":1529221489080},{"_id":"public/2018/06/17/2018-01-17-yanglei4/index.html","hash":"447a9143b110f1694455ebb62a1e0c6e173b7090","modified":1529221489080},{"_id":"public/2018/06/17/2018-01-09-yanglei2/index.html","hash":"d937c2774e3407bbdc8f28c7284269d08f13e0ee","modified":1529221489081},{"_id":"public/2018/06/17/2018-01-09-yanglei1/index.html","hash":"19ece8a73e4b0d3d90cd993e4b12ff31b0158c31","modified":1529221489081},{"_id":"public/archives/page/2/index.html","hash":"ecfa451a5aaf7fd2e1742191c1e129f244957bde","modified":1529221489081},{"_id":"public/archives/2018/page/2/index.html","hash":"2492a8a148f685cf3b451adab84991dcbbea42dd","modified":1529221489081},{"_id":"public/archives/2018/06/page/2/index.html","hash":"667ec87010168708251e6787e500220d01567e17","modified":1529221489081},{"_id":"public/categories/技术仓库/page/2/index.html","hash":"982c7f6cda738b7121993be64eaeda5c723ce70b","modified":1529221489081},{"_id":"public/page/2/index.html","hash":"33986d254c8b7a4cb5176c40b46b5108ce2d9b0a","modified":1529221489081},{"_id":"public/tags/react/index.html","hash":"1c8e66551996cba539cbd31194e9d5cb015ace85","modified":1529221489081},{"_id":"public/tags/nodeJS/index.html","hash":"97059ef0b41c1955b936e4cf0b534f5afeb645af","modified":1529221489081},{"_id":"public/tags/js/index.html","hash":"fdb93c2a16d8c228ba6a3448e2eb2272fd196d1a","modified":1529221489081},{"_id":"public/tags/WebGL/index.html","hash":"644b23a797b2aea458894ebe15d08705845dc497","modified":1529221489081},{"_id":"public/2018/06/17/2018-04-13-yanglei12/index.html","hash":"0c1437c2899eb33e4b540dc04cf1f980d80d2a3c","modified":1529221489081},{"_id":"public/2018/06/17/2018-04-13-yanglei11/index.html","hash":"d7fd6bf13d94cd0be57e0e128bf05a231527b0ee","modified":1529221489081},{"_id":"public/2018/06/17/2018-04-04-yanglei10/index.html","hash":"c228b8c7b82b8838d5acba09bdf78d98a0bfd14c","modified":1529221489081},{"_id":"public/2018/06/17/2018-03-13-yanglei9/index.html","hash":"71365b455eb9ce389ab9613c3f98480261cdb225","modified":1529221489081},{"_id":"public/2018/06/17/2018-02-05-yanglei8/index.html","hash":"7f4103c0689f6b5e42de99ceb890d9eacb72c27c","modified":1529221489082},{"_id":"public/2018/06/17/2018-01-24-yanglei6/index.html","hash":"9ba332a4ccad0c383f743f7298d9d653a890f496","modified":1529221489082},{"_id":"public/2018/06/17/2018-01-16-yanglei3/index.html","hash":"b0e4752fec0db6e39d96128a1723c2a717984885","modified":1529221489082},{"_id":"public/archives/index.html","hash":"39b0579669dfc7f2a4c130fa4984e6b7540890ef","modified":1529221489082},{"_id":"public/archives/2018/index.html","hash":"4d8b02a65a5a5aaf149d41548102b857763b802d","modified":1529221489082},{"_id":"public/archives/2018/06/index.html","hash":"9aacac9de7d2e973b058012ba73ef0aa5e964f15","modified":1529221489082},{"_id":"public/categories/技术仓库/index.html","hash":"5fa7e31177d0bfd75bc22b2a6d96fa3a53f3fdbb","modified":1529221489082},{"_id":"public/index.html","hash":"796890305a31ace1e8fbd2388106ce9459c4d3a9","modified":1529221489082},{"_id":"public/css/fonts/icomoon/icomoon.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529221489087},{"_id":"public/img/jelon.jpg","hash":"5a698f21552a8365ef44f7113665bff8121635cb","modified":1529221489093},{"_id":"public/img/default.png","hash":"a0e8360a185c7516bc2dddb25241daee67b42972","modified":1529221489093},{"_id":"public/img/loading.gif","hash":"92dcf9179379355f05cf2d1c8cceba930a2a674f","modified":1529221489093},{"_id":"public/img/scrolltoparrow.png","hash":"53bd140adb85b23d535d1e488550eda4624a58bd","modified":1529221489093},{"_id":"public/img/share.png","hash":"20a860aeb842a556d067deabb99f6bfc024c97d0","modified":1529221489093},{"_id":"public/img/wechat_jelon.png","hash":"f1e1cab54bfb69e7816b1d5f355100ea8b272ce4","modified":1529221489093},{"_id":"public/img/wechat_mp.jpg","hash":"d58b7796093ca8cdd4034b2dd28021c147199099","modified":1529221489093},{"_id":"public/img/url.png","hash":"be1f35666ed5bf03aa3f6db121bd03c407b158a7","modified":1529221489093},{"_id":"public/img/thumbnail/0.jpg","hash":"7285bbd93d25a0810df38b499fa2b9c201dd88f2","modified":1529221489093},{"_id":"public/img/lab/banner.jpg","hash":"daa0b3c13831b17182c3d587920f035c80816ae3","modified":1529221489094},{"_id":"public/img/thumbnail/1.jpg","hash":"d56409526e114f07de70b9f6be036ee8939626bb","modified":1529221489094},{"_id":"public/img/thumbnail/4.jpg","hash":"4ba83c3c4937b8068bcb9ed7002c186053482b86","modified":1529221489094},{"_id":"public/img/thumbnail/5.jpg","hash":"b30fe3c75c445789d83b3d0f2f7b8d456802d306","modified":1529221489094},{"_id":"public/img/thumbnail/6.jpg","hash":"767c9f7b42b7faf9966fcf87afc732045bf87167","modified":1529221489094},{"_id":"public/img/thumbnail/7.jpg","hash":"74a4ed49b8823f7e93cad8dc53ed2bcc07f33254","modified":1529221489094},{"_id":"public/img/thumbnail/8.jpg","hash":"ed356882b0a3015e7aec619bf22dd98e76a2dac8","modified":1529221489094},{"_id":"public/img/thumbnail/9.jpg","hash":"64aa3752db2dd53e3dbbc7a84967afd2cdedd43e","modified":1529221489094},{"_id":"public/css/fonts/homizio-nova/italic.otf","hash":"5b50719da49c1ac26793384b1b68055f01dd4e85","modified":1529221489094},{"_id":"public/css/fonts/homizio-nova/light.otf","hash":"4afcc511fe6937b8e8d79e649d70dfb4fff6b406","modified":1529221489094},{"_id":"public/css/fonts/homizio-nova/light_italic.otf","hash":"29c648cf7caa087f36b1e1e1c479eb63da35af73","modified":1529221489094},{"_id":"public/css/fonts/homizio-nova/italic.ttf","hash":"c62e2ba058f3dc49125dc514bcedde065ce64c5f","modified":1529221489094},{"_id":"public/css/fonts/icomoon/icomoon.eot","hash":"26de148529b318cb8159c70ef5adbe3667fb3e6d","modified":1529221489095},{"_id":"public/css/fonts/icomoon/icomoon.svg","hash":"90f9bbc99d84f36ffa811543bed70a2d79f363b7","modified":1529221489095},{"_id":"public/css/fonts/icomoon/icomoon.woff","hash":"a5a4ffc5ecda60e59beac6b0f096b25b243a2acb","modified":1529221489095},{"_id":"public/css/fonts/homizio-nova/regular.otf","hash":"c6e47b88647ac2b729c05d220cc5be19787b7835","modified":1529221489095},{"_id":"public/css/fonts/homizio-nova/light_italic.ttf","hash":"de9be5ed440fc380f2cbaa1683e94518d3d44e02","modified":1529221489095},{"_id":"public/img/no_found.png","hash":"aa383a9a73b3468b6a77ea3e3676b3f9d6e6ef0d","modified":1529221489412},{"_id":"public/img/unsigned_avatar.jpg","hash":"8343a845110fca8317440fcf61aae209eec57edf","modified":1529221489413},{"_id":"public/img/wechat_pay.jpg","hash":"8b2c2ec6b3ac7d88ac73cd15cf1f23a2bb6a435d","modified":1529221489413},{"_id":"public/img/thumbnail/3.jpg","hash":"7870fb47e46f645332174f356148bbc8163dfe13","modified":1529221489413},{"_id":"public/img/thumbnail/2.jpg","hash":"edbd90ed95301d390a8aa8243cd4c08a4d862402","modified":1529221489414},{"_id":"public/css/fonts/homizio-nova/light.ttf","hash":"2ba5f36f461b540823978956af8c33b57b0b8ab1","modified":1529221489414},{"_id":"public/css/fonts/homizio-nova/regular.ttf","hash":"0ab6cf8e5883d5693ba56065e4973cd8b3e896bc","modified":1529221489414},{"_id":"public/js/html5.js","hash":"4fefd28dcad6c973c44719ce8b3a8b82fe670a59","modified":1529221489416},{"_id":"public/js/main.js","hash":"457dc472d3a3aecfb57fdbe80d7d475c3ef5baf4","modified":1529221489416},{"_id":"public/css/style.css","hash":"175f729156524201d27f665c6007eb7552578e0c","modified":1529221489416},{"_id":"public/js/comment.js","hash":"62a95a65453e42dad2b8813c616b1be451e1a577","modified":1529221489416},{"_id":"public/img/leofe.jpg","hash":"d42f333fcfb5a8fb9c8eb9df1278fbb3cbeb2a58","modified":1529221489418},{"_id":"source/assets/img/10-2.jpg","hash":"51ee0d734047e070d1d4998c79f0f5fda96bc212","modified":1529209784049},{"_id":"source/assets/img/cry.jpg","hash":"0bc4f496193ddb7c33957dd0699f254f86d50dce","modified":1529209784068},{"_id":"source/assets/img/right.jpg","hash":"2c4922456e5f6bca68667371b77766c8629489bd","modified":1529209784071},{"_id":"source/assets/img/table.png","hash":"ceeec0750b393afdb253d9e02f5a4fa222b7523e","modified":1529209784071},{"_id":"source/assets/img/yanglei10-4.png","hash":"013e06deeba0f025fcdbaa62cbfb5e3350a2e30b","modified":1529209784255},{"_id":"source/assets/img/yanglei10-3.jpg","hash":"c3b9f0640f6d3e59a5f2ff96f184cc9f9dfd1c2f","modified":1529209784255},{"_id":"source/assets/img/yanglei12-1.jpg","hash":"c1b217a3c024b4dbc99c311d54803842227b345a","modified":1529209784255},{"_id":"source/assets/img/yanglei11-1.jpg","hash":"8e471802f86bd517693a6d48ca3a81042cb2de6e","modified":1529209784255},{"_id":"source/assets/img/yanglei6.jpg","hash":"86ece74d94054b8a36909ab92711a64d66730a8d","modified":1529209784256},{"_id":"source/assets/img/yanglei7-bug2.jpg","hash":"b23482434c5e5c3568ac5870aad18ae2110cf6b1","modified":1529209784256},{"_id":"source/assets/img/yanglei8-2.jpg","hash":"77a91285ed4c9982b95ffbb038cd370aec8b27cd","modified":1529209784257},{"_id":"source/assets/img/yanglei5.jpg","hash":"2bbe8249b9532646e85c41344a976dabfcfaffb0","modified":1529209784255},{"_id":"source/assets/img/yanglei8.jpg","hash":"ed1810c5299bcbb94878fb893ade621f425443ca","modified":1529209784257},{"_id":"source/assets/img/yanglei7-bug1.png","hash":"78759c28579b15fe5b37c8b8bdac181c58139451","modified":1529209784256},{"_id":"source/assets/img/yanglei8-1.png","hash":"9f2f3e635885db2c055c03e2b31f0edd6b07339f","modified":1529209784256},{"_id":"source/assets/img/10-2.png","hash":"f97f17786b4978256ebea3dced0a150ed6268577","modified":1529209784050},{"_id":"source/assets/img/gzh.png","hash":"5b4d70f9f4a159dd56abeba9fceb0f1ace418c8d","modified":1529209784071},{"_id":"source/assets/img/bolang1.gif","hash":"a5ae10f466ed72fc160fb78fde4547b79a92af42","modified":1529209784054},{"_id":"source/assets/img/bolang2.gif","hash":"a9e46ea8cd044176b2243ee09cc2b421340ee204","modified":1529209784059},{"_id":"source/assets/img/bolang3.gif","hash":"1e2c1e4a10844e2388e204c832c5ea9b6de3898f","modified":1529209784066},{"_id":"source/assets/img/bolang4.gif","hash":"7032e6ecda7817fce2d52af572175ac6a67404b7","modified":1529209784068},{"_id":"source/assets/img/yanglei10-1.gif","hash":"384e6aa3de7a6f2239180c70444760f0a928ad4e","modified":1529209784086},{"_id":"source/assets/img/yanglei10-2.gif","hash":"bc8941570200a9966989261fdb68fc5e7c713c91","modified":1529209784252},{"_id":"public/assets/img/10-2.jpg","hash":"51ee0d734047e070d1d4998c79f0f5fda96bc212","modified":1529221527382},{"_id":"public/assets/img/cry.jpg","hash":"0bc4f496193ddb7c33957dd0699f254f86d50dce","modified":1529221527382},{"_id":"public/assets/img/right.jpg","hash":"2c4922456e5f6bca68667371b77766c8629489bd","modified":1529221527382},{"_id":"public/assets/img/table.png","hash":"ceeec0750b393afdb253d9e02f5a4fa222b7523e","modified":1529221527382},{"_id":"public/assets/img/yanglei10-4.png","hash":"013e06deeba0f025fcdbaa62cbfb5e3350a2e30b","modified":1529221527382},{"_id":"public/assets/img/yanglei12-1.jpg","hash":"c1b217a3c024b4dbc99c311d54803842227b345a","modified":1529221527382},{"_id":"public/assets/img/yanglei10-3.jpg","hash":"c3b9f0640f6d3e59a5f2ff96f184cc9f9dfd1c2f","modified":1529221527382},{"_id":"public/assets/img/yanglei11-1.jpg","hash":"8e471802f86bd517693a6d48ca3a81042cb2de6e","modified":1529221527382},{"_id":"public/assets/img/yanglei7-bug2.jpg","hash":"b23482434c5e5c3568ac5870aad18ae2110cf6b1","modified":1529221527382},{"_id":"public/assets/img/yanglei6.jpg","hash":"86ece74d94054b8a36909ab92711a64d66730a8d","modified":1529221527382},{"_id":"public/assets/img/yanglei8-2.jpg","hash":"77a91285ed4c9982b95ffbb038cd370aec8b27cd","modified":1529221527383},{"_id":"public/assets/img/yanglei5.jpg","hash":"2bbe8249b9532646e85c41344a976dabfcfaffb0","modified":1529221527383},{"_id":"public/assets/img/yanglei8.jpg","hash":"ed1810c5299bcbb94878fb893ade621f425443ca","modified":1529221527383},{"_id":"public/assets/img/yanglei7-bug1.png","hash":"78759c28579b15fe5b37c8b8bdac181c58139451","modified":1529221527383},{"_id":"public/assets/img/yanglei8-1.png","hash":"9f2f3e635885db2c055c03e2b31f0edd6b07339f","modified":1529221527383},{"_id":"public/assets/img/10-2.png","hash":"f97f17786b4978256ebea3dced0a150ed6268577","modified":1529221527385},{"_id":"public/assets/img/gzh.png","hash":"5b4d70f9f4a159dd56abeba9fceb0f1ace418c8d","modified":1529221527392},{"_id":"public/assets/img/bolang1.gif","hash":"a5ae10f466ed72fc160fb78fde4547b79a92af42","modified":1529221527395},{"_id":"public/assets/img/bolang2.gif","hash":"a9e46ea8cd044176b2243ee09cc2b421340ee204","modified":1529221527395},{"_id":"public/assets/img/bolang3.gif","hash":"1e2c1e4a10844e2388e204c832c5ea9b6de3898f","modified":1529221527398},{"_id":"public/assets/img/bolang4.gif","hash":"7032e6ecda7817fce2d52af572175ac6a67404b7","modified":1529221527404},{"_id":"public/assets/img/yanglei10-1.gif","hash":"384e6aa3de7a6f2239180c70444760f0a928ad4e","modified":1529221527412},{"_id":"public/assets/img/yanglei10-2.gif","hash":"bc8941570200a9966989261fdb68fc5e7c713c91","modified":1529221527480}],"Category":[{"name":"技术仓库","_id":"cjiiizo4y0004o89kuak8b3v9"}],"Data":[],"Page":[{"title":"留言","date":"2016-02-01T12:29:57.000Z","pageid":"comment","_content":"","source":"comment/index.md","raw":"---\ntitle: 留言\ndate: 2016-02-01 20:29:57\npageid: comment\n---\n","updated":"2018-06-17T04:54:00.314Z","path":"comment/index.html","comments":1,"layout":"page","_id":"cjiiizo4u0001o89ksuig2mam","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2016-01-31T14:10:28.000Z","pageid":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-01-31 22:10:28\npageid: about\n---","updated":"2018-06-17T04:37:11.099Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjiiizo4x0003o89ko69p5bad","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"实验室","date":"2016-02-01T12:29:57.000Z","pageid":"lab","projects":{"blog_demo":{"title":"Blog Demo","time":"2016-10-10T00:00:00.000Z","content":{"1":{"name":"基于 vue + vuex + bootstrap 的 blog demo","link":"https://github.com/jangdelong/vue-blog-demo"}}},"hexo_theme_xups":{"title":"hexo-theme-xups 博客主题","time":"2016-03-12T00:00:00.000Z","content":{"1":{"name":"基于 hexo 静态博客系统的 博客主题 xups","link":"https://github.com/jangdelong/hexo-theme-xups"}}},"typecho_theme_xups":{"title":"Typecho 博客主题","time":"2015-10-15T00:00:00.000Z","content":{"1":{"name":"基于 php 博客系统 typecho 的主题 xups","link":"https://github.com/jangdelong/typecho-theme-xups"}}}},"_content":"","source":"lab/index.md","raw":"---\ntitle: 实验室\ndate: 2016-02-01 20:29:57\npageid: lab\n\nprojects:\n    blog_demo:\n        title: Blog Demo\n        time: 2016-10-10\n        content: \n            1:\n                name: 基于 vue + vuex + bootstrap 的 blog demo\n                link: https://github.com/jangdelong/vue-blog-demo\n    hexo_theme_xups:\n        title: hexo-theme-xups 博客主题\n        time: 2016-03-12\n        content:\n            1:\n                name: 基于 hexo 静态博客系统的 博客主题 xups\n                link: https://github.com/jangdelong/hexo-theme-xups\n    typecho_theme_xups:\n        title: Typecho 博客主题\n        time: 2015-10-15\n        content: \n            1:        \n                name: 基于 php 博客系统 typecho 的主题 xups\n                link: https://github.com/jangdelong/typecho-theme-xups  \n---\n","updated":"2018-06-17T04:37:11.099Z","path":"lab/index.html","comments":1,"layout":"page","_id":"cjiiizo5x001eo89kdg217g9n","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"react组件刷新","date":"2018-06-17T04:29:44.038Z","author":"leo","thumbnail":null,"blogexcerpt":"当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。","_content":"### react组件数据刷新\n\n当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。\n\n#### 此操作方式无法触发div内部数据变化\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            code: ''\n        }\n    }\n    changecode() {\n        this.state.code = '2'\n    }\n    render() {\n        return <div>{this.state.code}</div>\n    }\n}\n```\n解决以上绑定问题有一下2中解决方案：\n\n- 数据不存在state中，因为state是react中一个默认携带的数据，代码修改如下：\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.code = '';\n    }\n    changecode() {\n        this.code = '2'\n    }\n    render() {\n        return <div>{this.code}</div>\n    }\n}\n```\n- 另外一种方法是使用setState来改变state的值，才可以重新渲染，代码改动如下：\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            code: ''\n        }\n    }\n    changecode() {\n        this.setState({\n            code: 1\n        })\n    }\n    render() {\n        return <div>{this.state.code}</div>\n    }\n}\n```\n\n以上2种方法就可以动态更新data数据了。\n","source":"_posts/2018-01-09-yanglei1.markdown","raw":"---\ntitle: react组件刷新\ndate: {{ date }}\nauthor: leo\ntags: react\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。\n\n---\n### react组件数据刷新\n\n当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。\n\n#### 此操作方式无法触发div内部数据变化\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            code: ''\n        }\n    }\n    changecode() {\n        this.state.code = '2'\n    }\n    render() {\n        return <div>{this.state.code}</div>\n    }\n}\n```\n解决以上绑定问题有一下2中解决方案：\n\n- 数据不存在state中，因为state是react中一个默认携带的数据，代码修改如下：\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.code = '';\n    }\n    changecode() {\n        this.code = '2'\n    }\n    render() {\n        return <div>{this.code}</div>\n    }\n}\n```\n- 另外一种方法是使用setState来改变state的值，才可以重新渲染，代码改动如下：\n```\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            code: ''\n        }\n    }\n    changecode() {\n        this.setState({\n            code: 1\n        })\n    }\n    render() {\n        return <div>{this.state.code}</div>\n    }\n}\n```\n\n以上2种方法就可以动态更新data数据了。\n","slug":"2018-01-09-yanglei1","published":1,"updated":"2018-06-17T05:08:45.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo4r0000o89ksuvx84oc","content":"<h3 id=\"react组件数据刷新\"><a href=\"#react组件数据刷新\" class=\"headerlink\" title=\"react组件数据刷新\"></a>react组件数据刷新</h3><p>当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。</p>\n<h4 id=\"此操作方式无法触发div内部数据变化\"><a href=\"#此操作方式无法触发div内部数据变化\" class=\"headerlink\" title=\"此操作方式无法触发div内部数据变化\"></a>此操作方式无法触发div内部数据变化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            code: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.state.code = &apos;2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.state.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决以上绑定问题有一下2中解决方案：</p>\n<ul>\n<li><p>数据不存在state中，因为state是react中一个默认携带的数据，代码修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.code = &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.code = &apos;2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外一种方法是使用setState来改变state的值，才可以重新渲染，代码改动如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            code: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            code: 1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.state.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上2种方法就可以动态更新data数据了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"react组件数据刷新\"><a href=\"#react组件数据刷新\" class=\"headerlink\" title=\"react组件数据刷新\"></a>react组件数据刷新</h3><p>当数据卸载react的state中时，直接调用this.state.XX来触发自动渲染。</p>\n<h4 id=\"此操作方式无法触发div内部数据变化\"><a href=\"#此操作方式无法触发div内部数据变化\" class=\"headerlink\" title=\"此操作方式无法触发div内部数据变化\"></a>此操作方式无法触发div内部数据变化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            code: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.state.code = &apos;2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.state.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决以上绑定问题有一下2中解决方案：</p>\n<ul>\n<li><p>数据不存在state中，因为state是react中一个默认携带的数据，代码修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.code = &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.code = &apos;2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外一种方法是使用setState来改变state的值，才可以重新渲染，代码改动如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            code: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changecode() &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            code: 1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return &lt;div&gt;&#123;this.state.code&#125;&lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上2种方法就可以动态更新data数据了。</p>\n"},{"title":"react组件原有属性写法","date":"2018-06-17T04:29:44.038Z","author":"leo","thumbnail":null,"blogexcerpt":"需要禁用input的autocomplete属性。","_content":"\n### react组件原有属性写法\n\n场景：需要禁用input的autocomplete属性。\n\n原始写法：\n```\n<input autocomplete=\"off\"/>\n```\n如果react中采用同样写法(会报错)\n```\nrender() {\n    return <input autocomplete=\"off\"></input>\n}\n```\n经过调研发现，react中原有属性，需要使用驼峰命名法，正确写法如下：\n\n```\nrender() {\n    return <input autoComplete=\"off\"></input>\n}\n```\n此种情况使用于很多场景，如input的max-length => maxLength。","source":"_posts/2018-01-09-yanglei2.markdown","raw":"---\ntitle: react组件原有属性写法\ndate: {{ date }}\nauthor: leo\ntags: react\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 需要禁用input的autocomplete属性。\n\n---\n\n### react组件原有属性写法\n\n场景：需要禁用input的autocomplete属性。\n\n原始写法：\n```\n<input autocomplete=\"off\"/>\n```\n如果react中采用同样写法(会报错)\n```\nrender() {\n    return <input autocomplete=\"off\"></input>\n}\n```\n经过调研发现，react中原有属性，需要使用驼峰命名法，正确写法如下：\n\n```\nrender() {\n    return <input autoComplete=\"off\"></input>\n}\n```\n此种情况使用于很多场景，如input的max-length => maxLength。","slug":"2018-01-09-yanglei2","published":1,"updated":"2018-06-17T05:08:49.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo4v0002o89kwth32mfm","content":"<h3 id=\"react组件原有属性写法\"><a href=\"#react组件原有属性写法\" class=\"headerlink\" title=\"react组件原有属性写法\"></a>react组件原有属性写法</h3><p>场景：需要禁用input的autocomplete属性。</p>\n<p>原始写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input autocomplete=&quot;off&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果react中采用同样写法(会报错)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return &lt;input autocomplete=&quot;off&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过调研发现，react中原有属性，需要使用驼峰命名法，正确写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return &lt;input autoComplete=&quot;off&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此种情况使用于很多场景，如input的max-length =&gt; maxLength。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"react组件原有属性写法\"><a href=\"#react组件原有属性写法\" class=\"headerlink\" title=\"react组件原有属性写法\"></a>react组件原有属性写法</h3><p>场景：需要禁用input的autocomplete属性。</p>\n<p>原始写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input autocomplete=&quot;off&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果react中采用同样写法(会报错)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return &lt;input autocomplete=&quot;off&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过调研发现，react中原有属性，需要使用驼峰命名法，正确写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    return &lt;input autoComplete=&quot;off&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此种情况使用于很多场景，如input的max-length =&gt; maxLength。</p>\n"},{"title":"node下载功能开发","date":"2018-06-17T04:29:44.039Z","author":"leo","thumbnail":null,"blogexcerpt":"使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是[Archiver](https://www.npmjs.com/package/archiver)插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。","_content":"\n### 需求背景\n\n使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是[Archiver](https://www.npmjs.com/package/archiver)插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。\n\n### 插件基本用法\n\n插件基本用法文档中已经有了如下：\n```\nvar archiver = require('archiver');\nvar fs = require('fs');\n//创建一个archiver对象\nvar archive = archiver('zip', {\n  zlib: { level: 9 } // Sets the compression level.\n});\n//创建一个压缩包生成的输出路径,archiver会把数据流输入到此文件中\nvar output = fs.createWriteStream(__dirname + '/example.zip');\n//添加要压缩的文件，使用append，第一个参数可以为文件的数据流，也可以是一段字符串，第二个参数有多个配置，以下只使用了name，name为压缩完成后的文件名，注意，此处可以输出路径如: dir/b.js\narchive.append('我是文件内容',{name: '1.txt'});\n//如果添加的是一个文件路径名，可使用如下方法\narchive.file('file1.txt', { name: 'file4.txt' });\n//需要压缩文件通过管道输出到output中，来生成压缩包。\narchive.pipe(output);\n//结束archive对象生命周期\narchive.finalize();\n```\n\n### 当配合Express使用\n很多情况下可能不只是服务端自己来操作，可能是页面层调用一个接口，然后接口会返回一个压缩包，这种情况要怎么操作呢？\n页面层的调用方式通常情况下如下（以下以jquery为例）：\n```\n$.ajax({\n    url:'我是万恶的URL',\n    type: 'get',\n    success: function(data) {\n        //TODO Success code\n    }\n})\n```\n对应Archiver内部需要配合express如下改造\n\n```\nvar archiver = require('archiver');\nvar fs = require('fs');\nvar express = require('express');\n//首先搭建起来一个express服务器\nvar app = express();\nvar server = app.listen(80, () => {\n    console.log(`【${new Date()}】服务器启动!`);\n});\napp.use('/download', function(req, res, next) {\n    //需要给此请求添加类型，此处以zip为例\n    res.header('Content-Type', 'application/zip');\n    if (req.method == 'OPTIONS') {\n        res.send(200);\n    } else {\n        next();\n    }\n});\napp.get('/download', (req, res) => {\n    //创建一个支持GET的接口，\n    //压缩对应文件\n    var fs = require('fs');\n    var archive = archiver('zip', {\n    zlib: { level: 9 } // Sets the compression level.\n    });\n    archive.append('我是文件内容',{name: '1.txt'});\n    archive.file('file1.txt', { name: 'file4.txt' });\n    res.attachment('popui.zip');\n    archive.pipe(res);\n    archive.finalize();\n})\n```\n\n如果你按照此方写已经编写完成的话，恭喜你，已经完成了80%了，以为此种方式你会发现，压缩包会以数据流的方式在data中存在，你会疑问，此数据流要怎么来转化成zip呢？\n\n### 如何转化zip数据流\n\n其实此处我们只需要更改一下调用方式即可，此前使用的是ajax请求，返回值固然会进入data中，此处是无错的，但是想变成zip就只能望洋兴叹了。\n可以采用如下方式来操作：\n- 首先不能使用诸如AJAX的方式来请求。\n- 第二express不能使用post方式\n#### 改进方式如下\n- 采用GET方式\n- 采用href的方式来调用，代码参考下方\n```\n<a href=\"/download?id=1\"></a>\n```\n\n切记只能使用此方式才能直接弹出zip文件的保存界面。\n\n至此你已经完成了下载功能的开发\n\n### 参考文献\n\n\n- [官方express例子](https://github.com/archiverjs/node-archiver/blob/master/examples/express.js)\n- [StackOverFlow经典答案](https://stackoverflow.com/questions/20107303/dynamically-create-and-stream-zip-to-client)\n","source":"_posts/2018-01-16-yanglei3.markdown","raw":"---\ntitle: node下载功能开发\ndate: {{ date }}\nauthor: leo\ntags: nodeJS\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是[Archiver](https://www.npmjs.com/package/archiver)插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。\n---\n\n### 需求背景\n\n使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是[Archiver](https://www.npmjs.com/package/archiver)插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。\n\n### 插件基本用法\n\n插件基本用法文档中已经有了如下：\n```\nvar archiver = require('archiver');\nvar fs = require('fs');\n//创建一个archiver对象\nvar archive = archiver('zip', {\n  zlib: { level: 9 } // Sets the compression level.\n});\n//创建一个压缩包生成的输出路径,archiver会把数据流输入到此文件中\nvar output = fs.createWriteStream(__dirname + '/example.zip');\n//添加要压缩的文件，使用append，第一个参数可以为文件的数据流，也可以是一段字符串，第二个参数有多个配置，以下只使用了name，name为压缩完成后的文件名，注意，此处可以输出路径如: dir/b.js\narchive.append('我是文件内容',{name: '1.txt'});\n//如果添加的是一个文件路径名，可使用如下方法\narchive.file('file1.txt', { name: 'file4.txt' });\n//需要压缩文件通过管道输出到output中，来生成压缩包。\narchive.pipe(output);\n//结束archive对象生命周期\narchive.finalize();\n```\n\n### 当配合Express使用\n很多情况下可能不只是服务端自己来操作，可能是页面层调用一个接口，然后接口会返回一个压缩包，这种情况要怎么操作呢？\n页面层的调用方式通常情况下如下（以下以jquery为例）：\n```\n$.ajax({\n    url:'我是万恶的URL',\n    type: 'get',\n    success: function(data) {\n        //TODO Success code\n    }\n})\n```\n对应Archiver内部需要配合express如下改造\n\n```\nvar archiver = require('archiver');\nvar fs = require('fs');\nvar express = require('express');\n//首先搭建起来一个express服务器\nvar app = express();\nvar server = app.listen(80, () => {\n    console.log(`【${new Date()}】服务器启动!`);\n});\napp.use('/download', function(req, res, next) {\n    //需要给此请求添加类型，此处以zip为例\n    res.header('Content-Type', 'application/zip');\n    if (req.method == 'OPTIONS') {\n        res.send(200);\n    } else {\n        next();\n    }\n});\napp.get('/download', (req, res) => {\n    //创建一个支持GET的接口，\n    //压缩对应文件\n    var fs = require('fs');\n    var archive = archiver('zip', {\n    zlib: { level: 9 } // Sets the compression level.\n    });\n    archive.append('我是文件内容',{name: '1.txt'});\n    archive.file('file1.txt', { name: 'file4.txt' });\n    res.attachment('popui.zip');\n    archive.pipe(res);\n    archive.finalize();\n})\n```\n\n如果你按照此方写已经编写完成的话，恭喜你，已经完成了80%了，以为此种方式你会发现，压缩包会以数据流的方式在data中存在，你会疑问，此数据流要怎么来转化成zip呢？\n\n### 如何转化zip数据流\n\n其实此处我们只需要更改一下调用方式即可，此前使用的是ajax请求，返回值固然会进入data中，此处是无错的，但是想变成zip就只能望洋兴叹了。\n可以采用如下方式来操作：\n- 首先不能使用诸如AJAX的方式来请求。\n- 第二express不能使用post方式\n#### 改进方式如下\n- 采用GET方式\n- 采用href的方式来调用，代码参考下方\n```\n<a href=\"/download?id=1\"></a>\n```\n\n切记只能使用此方式才能直接弹出zip文件的保存界面。\n\n至此你已经完成了下载功能的开发\n\n### 参考文献\n\n\n- [官方express例子](https://github.com/archiverjs/node-archiver/blob/master/examples/express.js)\n- [StackOverFlow经典答案](https://stackoverflow.com/questions/20107303/dynamically-create-and-stream-zip-to-client)\n","slug":"2018-01-16-yanglei3","published":1,"updated":"2018-06-17T07:37:13.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo500006o89klsfyb41d","content":"<h3 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h3><p>使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是<a href=\"https://www.npmjs.com/package/archiver\" target=\"_blank\" rel=\"noopener\">Archiver</a>插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。</p>\n<h3 id=\"插件基本用法\"><a href=\"#插件基本用法\" class=\"headerlink\" title=\"插件基本用法\"></a>插件基本用法</h3><p>插件基本用法文档中已经有了如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var archiver = require(&apos;archiver&apos;);</span><br><span class=\"line\">var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">//创建一个archiver对象</span><br><span class=\"line\">var archive = archiver(&apos;zip&apos;, &#123;</span><br><span class=\"line\">  zlib: &#123; level: 9 &#125; // Sets the compression level.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//创建一个压缩包生成的输出路径,archiver会把数据流输入到此文件中</span><br><span class=\"line\">var output = fs.createWriteStream(__dirname + &apos;/example.zip&apos;);</span><br><span class=\"line\">//添加要压缩的文件，使用append，第一个参数可以为文件的数据流，也可以是一段字符串，第二个参数有多个配置，以下只使用了name，name为压缩完成后的文件名，注意，此处可以输出路径如: dir/b.js</span><br><span class=\"line\">archive.append(&apos;我是文件内容&apos;,&#123;name: &apos;1.txt&apos;&#125;);</span><br><span class=\"line\">//如果添加的是一个文件路径名，可使用如下方法</span><br><span class=\"line\">archive.file(&apos;file1.txt&apos;, &#123; name: &apos;file4.txt&apos; &#125;);</span><br><span class=\"line\">//需要压缩文件通过管道输出到output中，来生成压缩包。</span><br><span class=\"line\">archive.pipe(output);</span><br><span class=\"line\">//结束archive对象生命周期</span><br><span class=\"line\">archive.finalize();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"当配合Express使用\"><a href=\"#当配合Express使用\" class=\"headerlink\" title=\"当配合Express使用\"></a>当配合Express使用</h3><p>很多情况下可能不只是服务端自己来操作，可能是页面层调用一个接口，然后接口会返回一个压缩包，这种情况要怎么操作呢？<br>页面层的调用方式通常情况下如下（以下以jquery为例）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:&apos;我是万恶的URL&apos;,</span><br><span class=\"line\">    type: &apos;get&apos;,</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        //TODO Success code</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>对应Archiver内部需要配合express如下改造</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var archiver = require(&apos;archiver&apos;);</span><br><span class=\"line\">var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">//首先搭建起来一个express服务器</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">var server = app.listen(80, () =&gt; &#123;</span><br><span class=\"line\">    console.log(`【$&#123;new Date()&#125;】服务器启动!`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.use(&apos;/download&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">    //需要给此请求添加类型，此处以zip为例</span><br><span class=\"line\">    res.header(&apos;Content-Type&apos;, &apos;application/zip&apos;);</span><br><span class=\"line\">    if (req.method == &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">        res.send(200);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.get(&apos;/download&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">    //创建一个支持GET的接口，</span><br><span class=\"line\">    //压缩对应文件</span><br><span class=\"line\">    var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">    var archive = archiver(&apos;zip&apos;, &#123;</span><br><span class=\"line\">    zlib: &#123; level: 9 &#125; // Sets the compression level.</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    archive.append(&apos;我是文件内容&apos;,&#123;name: &apos;1.txt&apos;&#125;);</span><br><span class=\"line\">    archive.file(&apos;file1.txt&apos;, &#123; name: &apos;file4.txt&apos; &#125;);</span><br><span class=\"line\">    res.attachment(&apos;popui.zip&apos;);</span><br><span class=\"line\">    archive.pipe(res);</span><br><span class=\"line\">    archive.finalize();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果你按照此方写已经编写完成的话，恭喜你，已经完成了80%了，以为此种方式你会发现，压缩包会以数据流的方式在data中存在，你会疑问，此数据流要怎么来转化成zip呢？</p>\n<h3 id=\"如何转化zip数据流\"><a href=\"#如何转化zip数据流\" class=\"headerlink\" title=\"如何转化zip数据流\"></a>如何转化zip数据流</h3><p>其实此处我们只需要更改一下调用方式即可，此前使用的是ajax请求，返回值固然会进入data中，此处是无错的，但是想变成zip就只能望洋兴叹了。<br>可以采用如下方式来操作：</p>\n<ul>\n<li>首先不能使用诸如AJAX的方式来请求。</li>\n<li>第二express不能使用post方式<h4 id=\"改进方式如下\"><a href=\"#改进方式如下\" class=\"headerlink\" title=\"改进方式如下\"></a>改进方式如下</h4></li>\n<li>采用GET方式</li>\n<li>采用href的方式来调用，代码参考下方<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;/download?id=1&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>切记只能使用此方式才能直接弹出zip文件的保存界面。</p>\n<p>至此你已经完成了下载功能的开发</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://github.com/archiverjs/node-archiver/blob/master/examples/express.js\" target=\"_blank\" rel=\"noopener\">官方express例子</a></li>\n<li><a href=\"https://stackoverflow.com/questions/20107303/dynamically-create-and-stream-zip-to-client\" target=\"_blank\" rel=\"noopener\">StackOverFlow经典答案</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h3><p>使用nodejs开发服务端时，可能会有下载功能需求，而且nodeJS也有丰富的组件，因项目中使用的是<a href=\"https://www.npmjs.com/package/archiver\" target=\"_blank\" rel=\"noopener\">Archiver</a>插件，以下就简单的讲讲此插件的使用方式，此插件github上星不少，但是文档很粗糙。</p>\n<h3 id=\"插件基本用法\"><a href=\"#插件基本用法\" class=\"headerlink\" title=\"插件基本用法\"></a>插件基本用法</h3><p>插件基本用法文档中已经有了如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var archiver = require(&apos;archiver&apos;);</span><br><span class=\"line\">var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">//创建一个archiver对象</span><br><span class=\"line\">var archive = archiver(&apos;zip&apos;, &#123;</span><br><span class=\"line\">  zlib: &#123; level: 9 &#125; // Sets the compression level.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//创建一个压缩包生成的输出路径,archiver会把数据流输入到此文件中</span><br><span class=\"line\">var output = fs.createWriteStream(__dirname + &apos;/example.zip&apos;);</span><br><span class=\"line\">//添加要压缩的文件，使用append，第一个参数可以为文件的数据流，也可以是一段字符串，第二个参数有多个配置，以下只使用了name，name为压缩完成后的文件名，注意，此处可以输出路径如: dir/b.js</span><br><span class=\"line\">archive.append(&apos;我是文件内容&apos;,&#123;name: &apos;1.txt&apos;&#125;);</span><br><span class=\"line\">//如果添加的是一个文件路径名，可使用如下方法</span><br><span class=\"line\">archive.file(&apos;file1.txt&apos;, &#123; name: &apos;file4.txt&apos; &#125;);</span><br><span class=\"line\">//需要压缩文件通过管道输出到output中，来生成压缩包。</span><br><span class=\"line\">archive.pipe(output);</span><br><span class=\"line\">//结束archive对象生命周期</span><br><span class=\"line\">archive.finalize();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"当配合Express使用\"><a href=\"#当配合Express使用\" class=\"headerlink\" title=\"当配合Express使用\"></a>当配合Express使用</h3><p>很多情况下可能不只是服务端自己来操作，可能是页面层调用一个接口，然后接口会返回一个压缩包，这种情况要怎么操作呢？<br>页面层的调用方式通常情况下如下（以下以jquery为例）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:&apos;我是万恶的URL&apos;,</span><br><span class=\"line\">    type: &apos;get&apos;,</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        //TODO Success code</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>对应Archiver内部需要配合express如下改造</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var archiver = require(&apos;archiver&apos;);</span><br><span class=\"line\">var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">//首先搭建起来一个express服务器</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">var server = app.listen(80, () =&gt; &#123;</span><br><span class=\"line\">    console.log(`【$&#123;new Date()&#125;】服务器启动!`);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.use(&apos;/download&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">    //需要给此请求添加类型，此处以zip为例</span><br><span class=\"line\">    res.header(&apos;Content-Type&apos;, &apos;application/zip&apos;);</span><br><span class=\"line\">    if (req.method == &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">        res.send(200);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.get(&apos;/download&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">    //创建一个支持GET的接口，</span><br><span class=\"line\">    //压缩对应文件</span><br><span class=\"line\">    var fs = require(&apos;fs&apos;);</span><br><span class=\"line\">    var archive = archiver(&apos;zip&apos;, &#123;</span><br><span class=\"line\">    zlib: &#123; level: 9 &#125; // Sets the compression level.</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    archive.append(&apos;我是文件内容&apos;,&#123;name: &apos;1.txt&apos;&#125;);</span><br><span class=\"line\">    archive.file(&apos;file1.txt&apos;, &#123; name: &apos;file4.txt&apos; &#125;);</span><br><span class=\"line\">    res.attachment(&apos;popui.zip&apos;);</span><br><span class=\"line\">    archive.pipe(res);</span><br><span class=\"line\">    archive.finalize();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果你按照此方写已经编写完成的话，恭喜你，已经完成了80%了，以为此种方式你会发现，压缩包会以数据流的方式在data中存在，你会疑问，此数据流要怎么来转化成zip呢？</p>\n<h3 id=\"如何转化zip数据流\"><a href=\"#如何转化zip数据流\" class=\"headerlink\" title=\"如何转化zip数据流\"></a>如何转化zip数据流</h3><p>其实此处我们只需要更改一下调用方式即可，此前使用的是ajax请求，返回值固然会进入data中，此处是无错的，但是想变成zip就只能望洋兴叹了。<br>可以采用如下方式来操作：</p>\n<ul>\n<li>首先不能使用诸如AJAX的方式来请求。</li>\n<li>第二express不能使用post方式<h4 id=\"改进方式如下\"><a href=\"#改进方式如下\" class=\"headerlink\" title=\"改进方式如下\"></a>改进方式如下</h4></li>\n<li>采用GET方式</li>\n<li>采用href的方式来调用，代码参考下方<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;/download?id=1&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>切记只能使用此方式才能直接弹出zip文件的保存界面。</p>\n<p>至此你已经完成了下载功能的开发</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://github.com/archiverjs/node-archiver/blob/master/examples/express.js\" target=\"_blank\" rel=\"noopener\">官方express例子</a></li>\n<li><a href=\"https://stackoverflow.com/questions/20107303/dynamically-create-and-stream-zip-to-client\" target=\"_blank\" rel=\"noopener\">StackOverFlow经典答案</a></li>\n</ul>\n"},{"title":"Seajs模块压缩后引用其他模块无效","date":"2018-06-17T04:29:44.039Z","author":"leo","thumbnail":null,"blogexcerpt":"Seajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。","_content":"\nSeajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。\n\n### 坑的问题\n\n当seajs的模块正常使用时是无需添加dependencies的，也就是前依赖，因为构建工具一般都会自动添加。\n\nWhat？ 不知道什么是前依赖？看看如下代码\n\n\n//一下为一个seajs的模块基础部分\n```\ndefine(id,[dependencies], function(require, exports, module) {\n})\n```\n\n\n以上代码中id为模块ID，dependencies就是前依赖，顾名思义，在执行function时必须会先加载完[]里面的内容。\n\n默认情况下这个值大家是不需要添加的，因为构建工具会自动添加，不压缩的情况下Seajs也会自动抓取require里面的值，来帮忙首先加载前依赖。\n\n##### 坑来了\n\n当你未使用构建工具，并且通过uglify对Seajs模块进行混淆压缩时，代码在调用这个模块时，模块中原本require进来的内容都加载不进来。简言之：报错了。\n\n![进坑了](/assets/img/cry.jpg)\n\n\n\n### 原因\n经过一天的细心排查以及对Seajs的源码的一些阅读，终于找到了问题所在。\n> 因为Seajs在省略前依赖的时候，框架会通过require来捕捉所有前依赖并在代码执行前进行加载。简言之就是，框架帮你添加了前依赖,但是经过了uglify混淆之后，require变成了一个单字母，结果就是Seajs无法检测到require，也就无法帮忙添加前依赖，此时需要自己手动添加。\n\n### 解决办法\n\n1. 压缩前自己手动添加上前依赖\n2. 可以在uglify压缩时，配置参数来使压缩时不会将require混淆掉。[UglifyJS文档](https://www.npmjs.com/package/uglify-js#mangle)\n\nUglify配置\n```\nvar compressJS = UglifyJS.minify(orig_code,{\n    mangle: {\n        reserved: ['require']\n    }\n});\n```\n","source":"_posts/2018-01-17-yanglei4.md","raw":"---\ntitle: Seajs模块压缩后引用其他模块无效\ndate: {{ date }}\nauthor: leo\ntags: js\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: Seajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。\n---\n\nSeajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。\n\n### 坑的问题\n\n当seajs的模块正常使用时是无需添加dependencies的，也就是前依赖，因为构建工具一般都会自动添加。\n\nWhat？ 不知道什么是前依赖？看看如下代码\n\n\n//一下为一个seajs的模块基础部分\n```\ndefine(id,[dependencies], function(require, exports, module) {\n})\n```\n\n\n以上代码中id为模块ID，dependencies就是前依赖，顾名思义，在执行function时必须会先加载完[]里面的内容。\n\n默认情况下这个值大家是不需要添加的，因为构建工具会自动添加，不压缩的情况下Seajs也会自动抓取require里面的值，来帮忙首先加载前依赖。\n\n##### 坑来了\n\n当你未使用构建工具，并且通过uglify对Seajs模块进行混淆压缩时，代码在调用这个模块时，模块中原本require进来的内容都加载不进来。简言之：报错了。\n\n![进坑了](/assets/img/cry.jpg)\n\n\n\n### 原因\n经过一天的细心排查以及对Seajs的源码的一些阅读，终于找到了问题所在。\n> 因为Seajs在省略前依赖的时候，框架会通过require来捕捉所有前依赖并在代码执行前进行加载。简言之就是，框架帮你添加了前依赖,但是经过了uglify混淆之后，require变成了一个单字母，结果就是Seajs无法检测到require，也就无法帮忙添加前依赖，此时需要自己手动添加。\n\n### 解决办法\n\n1. 压缩前自己手动添加上前依赖\n2. 可以在uglify压缩时，配置参数来使压缩时不会将require混淆掉。[UglifyJS文档](https://www.npmjs.com/package/uglify-js#mangle)\n\nUglify配置\n```\nvar compressJS = UglifyJS.minify(orig_code,{\n    mangle: {\n        reserved: ['require']\n    }\n});\n```\n","slug":"2018-01-17-yanglei4","published":1,"updated":"2018-06-17T07:37:50.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo510007o89kta92y2ps","content":"<p>Seajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。</p>\n<h3 id=\"坑的问题\"><a href=\"#坑的问题\" class=\"headerlink\" title=\"坑的问题\"></a>坑的问题</h3><p>当seajs的模块正常使用时是无需添加dependencies的，也就是前依赖，因为构建工具一般都会自动添加。</p>\n<p>What？ 不知道什么是前依赖？看看如下代码</p>\n<p>//一下为一个seajs的模块基础部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id,[dependencies], function(require, exports, module) &#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上代码中id为模块ID，dependencies就是前依赖，顾名思义，在执行function时必须会先加载完[]里面的内容。</p>\n<p>默认情况下这个值大家是不需要添加的，因为构建工具会自动添加，不压缩的情况下Seajs也会自动抓取require里面的值，来帮忙首先加载前依赖。</p>\n<h5 id=\"坑来了\"><a href=\"#坑来了\" class=\"headerlink\" title=\"坑来了\"></a>坑来了</h5><p>当你未使用构建工具，并且通过uglify对Seajs模块进行混淆压缩时，代码在调用这个模块时，模块中原本require进来的内容都加载不进来。简言之：报错了。</p>\n<p><img src=\"/assets/img/cry.jpg\" alt=\"进坑了\"></p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>经过一天的细心排查以及对Seajs的源码的一些阅读，终于找到了问题所在。</p>\n<blockquote>\n<p>因为Seajs在省略前依赖的时候，框架会通过require来捕捉所有前依赖并在代码执行前进行加载。简言之就是，框架帮你添加了前依赖,但是经过了uglify混淆之后，require变成了一个单字母，结果就是Seajs无法检测到require，也就无法帮忙添加前依赖，此时需要自己手动添加。</p>\n</blockquote>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><ol>\n<li>压缩前自己手动添加上前依赖</li>\n<li>可以在uglify压缩时，配置参数来使压缩时不会将require混淆掉。<a href=\"https://www.npmjs.com/package/uglify-js#mangle\" target=\"_blank\" rel=\"noopener\">UglifyJS文档</a></li>\n</ol>\n<p>Uglify配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var compressJS = UglifyJS.minify(orig_code,&#123;</span><br><span class=\"line\">    mangle: &#123;</span><br><span class=\"line\">        reserved: [&apos;require&apos;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Seajs作为一款业界比较知名的模块加载库，的确为开发带来了很多便利，当然近期通过对seajs的一些操作，让自己又掉进了一个坑中。</p>\n<h3 id=\"坑的问题\"><a href=\"#坑的问题\" class=\"headerlink\" title=\"坑的问题\"></a>坑的问题</h3><p>当seajs的模块正常使用时是无需添加dependencies的，也就是前依赖，因为构建工具一般都会自动添加。</p>\n<p>What？ 不知道什么是前依赖？看看如下代码</p>\n<p>//一下为一个seajs的模块基础部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id,[dependencies], function(require, exports, module) &#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上代码中id为模块ID，dependencies就是前依赖，顾名思义，在执行function时必须会先加载完[]里面的内容。</p>\n<p>默认情况下这个值大家是不需要添加的，因为构建工具会自动添加，不压缩的情况下Seajs也会自动抓取require里面的值，来帮忙首先加载前依赖。</p>\n<h5 id=\"坑来了\"><a href=\"#坑来了\" class=\"headerlink\" title=\"坑来了\"></a>坑来了</h5><p>当你未使用构建工具，并且通过uglify对Seajs模块进行混淆压缩时，代码在调用这个模块时，模块中原本require进来的内容都加载不进来。简言之：报错了。</p>\n<p><img src=\"/assets/img/cry.jpg\" alt=\"进坑了\"></p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>经过一天的细心排查以及对Seajs的源码的一些阅读，终于找到了问题所在。</p>\n<blockquote>\n<p>因为Seajs在省略前依赖的时候，框架会通过require来捕捉所有前依赖并在代码执行前进行加载。简言之就是，框架帮你添加了前依赖,但是经过了uglify混淆之后，require变成了一个单字母，结果就是Seajs无法检测到require，也就无法帮忙添加前依赖，此时需要自己手动添加。</p>\n</blockquote>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><ol>\n<li>压缩前自己手动添加上前依赖</li>\n<li>可以在uglify压缩时，配置参数来使压缩时不会将require混淆掉。<a href=\"https://www.npmjs.com/package/uglify-js#mangle\" target=\"_blank\" rel=\"noopener\">UglifyJS文档</a></li>\n</ol>\n<p>Uglify配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var compressJS = UglifyJS.minify(orig_code,&#123;</span><br><span class=\"line\">    mangle: &#123;</span><br><span class=\"line\">        reserved: [&apos;require&apos;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"WebGL第一课-基础介绍","date":"2018-06-17T04:29:44.040Z","author":"leo","thumbnail":null,"blogexcerpt":"随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。","_content":"\n## 背景\n随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。\nWebGL不是官方标准，其实是khronos团队去制定的标准。\n\n## WebGl基础\nWebGL是前端3D语言，从名字就可以看出，跟OpenGL有一定关系。没错，Webgl是从OpenGL转变来的。实际上，WebGL来源于OpenGl ES2.0，并在其基础上做了一层javascript的兼容处理，也就是简化版本的OpenGl，所以在WebGL中依旧能看到很多GLSE语言编写的痕迹。\n> [检测浏览器是否支持webgl](http://webglreport.com)\n\n### 创建webGL对象\n不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理\n```\nvar canvas = document.getElementById(\"glcanvas\");\ngl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n```\n\n### 创建着色器编码\nWebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。\n\n\nWebGL需要两种着色器\n\n- 顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。**顶点(Vertex)**是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。\n- 片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。**片元(fragment)**是一个WebGL的术语，你可以将其理解成像素。\n\n > **着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译**\n\n创建顶点着色器：\n```\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n创建片元着色器：\n```\n var FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n浏览器的整个过程如下：\n\n![webgl渲染过程](/assets/img/yanglei5.jpg)\n\n着色器中包含几个内置变量：**gl_Position, gl_PointSize, gl_FragColor**。\n>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，**正确应为：(1.0,1.0,1.0,1.0)**\n\n- **gl_Position**: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为**齐次坐标**，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。\n\n- **gl_PointSize**：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。\n\n- **gl_FragColor**：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从**0.0-1.0**对应Javascript中的**#00-#FF**。\n\n## 坐标系\nWebGL采用右手坐标系，如图所示：\n\n![webgl渲染过程](/assets/img/right.jpg)\n\n> 基础部分介绍到此，大家也基本了解WebGL与着色器了，下一课我们一起来运用着色器绘制一个圆点，[下一课](/yanglei/2018/01/24/yanglei6.html)。\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>\n","source":"_posts/2018-01-23-yanglei5.md","raw":"---\ntitle: WebGL第一课-基础介绍\ndate: {{ date }}\nauthor: leo\ntags: WebGL\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。\n---\n\n## 背景\n随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。\nWebGL不是官方标准，其实是khronos团队去制定的标准。\n\n## WebGl基础\nWebGL是前端3D语言，从名字就可以看出，跟OpenGL有一定关系。没错，Webgl是从OpenGL转变来的。实际上，WebGL来源于OpenGl ES2.0，并在其基础上做了一层javascript的兼容处理，也就是简化版本的OpenGl，所以在WebGL中依旧能看到很多GLSE语言编写的痕迹。\n> [检测浏览器是否支持webgl](http://webglreport.com)\n\n### 创建webGL对象\n不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理\n```\nvar canvas = document.getElementById(\"glcanvas\");\ngl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n```\n\n### 创建着色器编码\nWebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。\n\n\nWebGL需要两种着色器\n\n- 顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。**顶点(Vertex)**是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。\n- 片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。**片元(fragment)**是一个WebGL的术语，你可以将其理解成像素。\n\n > **着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译**\n\n创建顶点着色器：\n```\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n创建片元着色器：\n```\n var FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n浏览器的整个过程如下：\n\n![webgl渲染过程](/assets/img/yanglei5.jpg)\n\n着色器中包含几个内置变量：**gl_Position, gl_PointSize, gl_FragColor**。\n>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，**正确应为：(1.0,1.0,1.0,1.0)**\n\n- **gl_Position**: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为**齐次坐标**，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。\n\n- **gl_PointSize**：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。\n\n- **gl_FragColor**：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从**0.0-1.0**对应Javascript中的**#00-#FF**。\n\n## 坐标系\nWebGL采用右手坐标系，如图所示：\n\n![webgl渲染过程](/assets/img/right.jpg)\n\n> 基础部分介绍到此，大家也基本了解WebGL与着色器了，下一课我们一起来运用着色器绘制一个圆点，[下一课](/yanglei/2018/01/24/yanglei6.html)。\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>\n","slug":"2018-01-23-yanglei5","published":1,"updated":"2018-06-17T07:39:59.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo520008o89kurtz1dng","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。<br>WebGL不是官方标准，其实是khronos团队去制定的标准。</p>\n<h2 id=\"WebGl基础\"><a href=\"#WebGl基础\" class=\"headerlink\" title=\"WebGl基础\"></a>WebGl基础</h2><p>WebGL是前端3D语言，从名字就可以看出，跟OpenGL有一定关系。没错，Webgl是从OpenGL转变来的。实际上，WebGL来源于OpenGl ES2.0，并在其基础上做了一层javascript的兼容处理，也就是简化版本的OpenGl，所以在WebGL中依旧能看到很多GLSE语言编写的痕迹。</p>\n<blockquote>\n<p><a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">检测浏览器是否支持webgl</a></p>\n</blockquote>\n<h3 id=\"创建webGL对象\"><a href=\"#创建webGL对象\" class=\"headerlink\" title=\"创建webGL对象\"></a>创建webGL对象</h3><p>不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建着色器编码\"><a href=\"#创建着色器编码\" class=\"headerlink\" title=\"创建着色器编码\"></a>创建着色器编码</h3><p>WebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。</p>\n<p>WebGL需要两种着色器</p>\n<ul>\n<li>顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点(Vertex)</strong>是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。</li>\n<li><p>片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。<strong>片元(fragment)</strong>是一个WebGL的术语，你可以将其理解成像素。</p>\n<blockquote>\n<p><strong>着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>创建顶点着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>创建片元着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器的整个过程如下：</p>\n<p><img src=\"/assets/img/yanglei5.jpg\" alt=\"webgl渲染过程\"></p>\n<p>着色器中包含几个内置变量：<strong>gl_Position, gl_PointSize, gl_FragColor</strong>。</p>\n<blockquote>\n<p>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，<strong>正确应为：(1.0,1.0,1.0,1.0)</strong></p>\n</blockquote>\n<ul>\n<li><p><strong>gl_Position</strong>: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为<strong>齐次坐标</strong>，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。</p>\n</li>\n<li><p><strong>gl_PointSize</strong>：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。</p>\n</li>\n<li><p><strong>gl_FragColor</strong>：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从<strong>0.0-1.0</strong>对应Javascript中的<strong>#00-#FF</strong>。</p>\n</li>\n</ul>\n<h2 id=\"坐标系\"><a href=\"#坐标系\" class=\"headerlink\" title=\"坐标系\"></a>坐标系</h2><p>WebGL采用右手坐标系，如图所示：</p>\n<p><img src=\"/assets/img/right.jpg\" alt=\"webgl渲染过程\"></p>\n<blockquote>\n<p>基础部分介绍到此，大家也基本了解WebGL与着色器了，下一课我们一起来运用着色器绘制一个圆点，<a href=\"/yanglei/2018/01/24/yanglei6.html\">下一课</a>。</p>\n</blockquote>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着互联网的发展，出现了各式各样的技术，html也已经到达了5.0的版本，前几天也发布了最新的5.1，Web前端能承载越来越多的功能。自从5.0发布后了风靡一时的canvas、video、audio等，一下把flash逼入死角，一时间各种音频、游戏、视频网站都换成了h5来开发，提高了性能以及跨平台的作用。而且随着技术的发展，必然会迎来web的3D时代，随着WebGl的到来，预示着web的3D时代真正来临。<br>WebGL不是官方标准，其实是khronos团队去制定的标准。</p>\n<h2 id=\"WebGl基础\"><a href=\"#WebGl基础\" class=\"headerlink\" title=\"WebGl基础\"></a>WebGl基础</h2><p>WebGL是前端3D语言，从名字就可以看出，跟OpenGL有一定关系。没错，Webgl是从OpenGL转变来的。实际上，WebGL来源于OpenGl ES2.0，并在其基础上做了一层javascript的兼容处理，也就是简化版本的OpenGl，所以在WebGL中依旧能看到很多GLSE语言编写的痕迹。</p>\n<blockquote>\n<p><a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">检测浏览器是否支持webgl</a></p>\n</blockquote>\n<h3 id=\"创建webGL对象\"><a href=\"#创建webGL对象\" class=\"headerlink\" title=\"创建webGL对象\"></a>创建webGL对象</h3><p>不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建着色器编码\"><a href=\"#创建着色器编码\" class=\"headerlink\" title=\"创建着色器编码\"></a>创建着色器编码</h3><p>WebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。</p>\n<p>WebGL需要两种着色器</p>\n<ul>\n<li>顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点(Vertex)</strong>是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。</li>\n<li><p>片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。<strong>片元(fragment)</strong>是一个WebGL的术语，你可以将其理解成像素。</p>\n<blockquote>\n<p><strong>着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>创建顶点着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>创建片元着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器的整个过程如下：</p>\n<p><img src=\"/assets/img/yanglei5.jpg\" alt=\"webgl渲染过程\"></p>\n<p>着色器中包含几个内置变量：<strong>gl_Position, gl_PointSize, gl_FragColor</strong>。</p>\n<blockquote>\n<p>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，<strong>正确应为：(1.0,1.0,1.0,1.0)</strong></p>\n</blockquote>\n<ul>\n<li><p><strong>gl_Position</strong>: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为<strong>齐次坐标</strong>，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。</p>\n</li>\n<li><p><strong>gl_PointSize</strong>：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。</p>\n</li>\n<li><p><strong>gl_FragColor</strong>：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从<strong>0.0-1.0</strong>对应Javascript中的<strong>#00-#FF</strong>。</p>\n</li>\n</ul>\n<h2 id=\"坐标系\"><a href=\"#坐标系\" class=\"headerlink\" title=\"坐标系\"></a>坐标系</h2><p>WebGL采用右手坐标系，如图所示：</p>\n<p><img src=\"/assets/img/right.jpg\" alt=\"webgl渲染过程\"></p>\n<blockquote>\n<p>基础部分介绍到此，大家也基本了解WebGL与着色器了，下一课我们一起来运用着色器绘制一个圆点，<a href=\"/yanglei/2018/01/24/yanglei6.html\">下一课</a>。</p>\n</blockquote>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n"},{"title":"WebGL第二课-着色器使用","date":"2018-06-17T04:29:44.040Z","author":"leo","thumbnail":null,"blogexcerpt":"上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。","_content":"\n上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。\n\n### 创建WebGl与着色器编码\n\n第一步内容为第一课讲解部分：\n\n```\nvar canvas = document.getElementById(\"glcanvas\");\nvar gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\nvar FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n### 创建承载着色器的程序\n着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。\n```\nvar program = gl.createProgram();\n```\n\n### 创建着色器\n使用webgl程序创建一个能承载OPENGL ES程序的容器\n```\n//创建顶点着色器\nvar vShader = gl.createShader(gl.VERTEX_SHADER);\n//创建片元着色器\nvar fShader = gl.createShader(gl.FRAGMENT_SHADER);\n```\n\n### shader容器与着色器绑定\n```\ngl.shaderSource(vShader, VSHADER_SOURCE);\ngl.shaderSource(fShader, FSHADER_SOURCE);\n```\n\n### 将GLSE语言编译成浏览器可用代码\n```\ngl.compileShader(vShader);\ngl.compileShader(fShader);\n```\n\n### 将着色器添加到程序上\n```\ngl.attachShader(program, vShader);\ngl.attachShader(program, fShader);\n```\n\n### 链接程序\n在链接操作执行以后，可以任意修改shader的源代码，对shader重新编译不会影响整个程序，除非重新链接程序\n```\ngl.linkProgram(program);\n```\n\n## 使用着色器\n加载并使用链接好的程序\n```\ngl.useProgram(program);\n```\n\n### 使用着色器画一个点\n```\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\ngl.drawArrays(gl.POINTS, 0 ,1);\n```\n\n> **gl.clearColor()**设置清空画布的颜色，参数为指定的颜色，颜色依旧采用GLES语法，颜色值范围0.0-1.1\n\n> **gl.clear(buffer)**将指定缓冲区设定为预定的值。如果清空的是颜色缓冲区，那么将使用gl.clearColor()指定值（作为预定值）\n\n##### buffer可设定值\n\n- **gl.COLOR_BUFFER_BIT**：指定颜色缓存\n- **gl.DEPTH_BUFFER_BIT**：指定深度缓冲区\n- **gl.STENCIL_BUFFER_BIT**：指定模板缓冲区\n\n---\n\n\n##### 我们来看一看最终结果\n\n![我是图片的Alt](/assets/img/yanglei6.jpg)\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>\n","source":"_posts/2018-01-24-yanglei6.md","raw":"---\ntitle: WebGL第二课-着色器使用\ndate: {{ date }}\nauthor: leo\ntags: WebGL\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。\n---\n\n上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。\n\n### 创建WebGl与着色器编码\n\n第一步内容为第一课讲解部分：\n\n```\nvar canvas = document.getElementById(\"glcanvas\");\nvar gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\nvar FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n### 创建承载着色器的程序\n着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。\n```\nvar program = gl.createProgram();\n```\n\n### 创建着色器\n使用webgl程序创建一个能承载OPENGL ES程序的容器\n```\n//创建顶点着色器\nvar vShader = gl.createShader(gl.VERTEX_SHADER);\n//创建片元着色器\nvar fShader = gl.createShader(gl.FRAGMENT_SHADER);\n```\n\n### shader容器与着色器绑定\n```\ngl.shaderSource(vShader, VSHADER_SOURCE);\ngl.shaderSource(fShader, FSHADER_SOURCE);\n```\n\n### 将GLSE语言编译成浏览器可用代码\n```\ngl.compileShader(vShader);\ngl.compileShader(fShader);\n```\n\n### 将着色器添加到程序上\n```\ngl.attachShader(program, vShader);\ngl.attachShader(program, fShader);\n```\n\n### 链接程序\n在链接操作执行以后，可以任意修改shader的源代码，对shader重新编译不会影响整个程序，除非重新链接程序\n```\ngl.linkProgram(program);\n```\n\n## 使用着色器\n加载并使用链接好的程序\n```\ngl.useProgram(program);\n```\n\n### 使用着色器画一个点\n```\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\ngl.drawArrays(gl.POINTS, 0 ,1);\n```\n\n> **gl.clearColor()**设置清空画布的颜色，参数为指定的颜色，颜色依旧采用GLES语法，颜色值范围0.0-1.1\n\n> **gl.clear(buffer)**将指定缓冲区设定为预定的值。如果清空的是颜色缓冲区，那么将使用gl.clearColor()指定值（作为预定值）\n\n##### buffer可设定值\n\n- **gl.COLOR_BUFFER_BIT**：指定颜色缓存\n- **gl.DEPTH_BUFFER_BIT**：指定深度缓冲区\n- **gl.STENCIL_BUFFER_BIT**：指定模板缓冲区\n\n---\n\n\n##### 我们来看一看最终结果\n\n![我是图片的Alt](/assets/img/yanglei6.jpg)\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>\n","slug":"2018-01-24-yanglei6","published":1,"updated":"2018-06-17T07:39:54.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo55000co89k6yj9zxln","content":"<p>上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。</p>\n<h3 id=\"创建WebGl与着色器编码\"><a href=\"#创建WebGl与着色器编码\" class=\"headerlink\" title=\"创建WebGl与着色器编码\"></a>创建WebGl与着色器编码</h3><p>第一步内容为第一课讲解部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">var gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建承载着色器的程序\"><a href=\"#创建承载着色器的程序\" class=\"headerlink\" title=\"创建承载着色器的程序\"></a>创建承载着色器的程序</h3><p>着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var program = gl.createProgram();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建着色器\"><a href=\"#创建着色器\" class=\"headerlink\" title=\"创建着色器\"></a>创建着色器</h3><p>使用webgl程序创建一个能承载OPENGL ES程序的容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建顶点着色器</span><br><span class=\"line\">var vShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">//创建片元着色器</span><br><span class=\"line\">var fShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"shader容器与着色器绑定\"><a href=\"#shader容器与着色器绑定\" class=\"headerlink\" title=\"shader容器与着色器绑定\"></a>shader容器与着色器绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.shaderSource(vShader, VSHADER_SOURCE);</span><br><span class=\"line\">gl.shaderSource(fShader, FSHADER_SOURCE);</span><br></pre></td></tr></table></figure>\n<h3 id=\"将GLSE语言编译成浏览器可用代码\"><a href=\"#将GLSE语言编译成浏览器可用代码\" class=\"headerlink\" title=\"将GLSE语言编译成浏览器可用代码\"></a>将GLSE语言编译成浏览器可用代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.compileShader(vShader);</span><br><span class=\"line\">gl.compileShader(fShader);</span><br></pre></td></tr></table></figure>\n<h3 id=\"将着色器添加到程序上\"><a href=\"#将着色器添加到程序上\" class=\"headerlink\" title=\"将着色器添加到程序上\"></a>将着色器添加到程序上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.attachShader(program, vShader);</span><br><span class=\"line\">gl.attachShader(program, fShader);</span><br></pre></td></tr></table></figure>\n<h3 id=\"链接程序\"><a href=\"#链接程序\" class=\"headerlink\" title=\"链接程序\"></a>链接程序</h3><p>在链接操作执行以后，可以任意修改shader的源代码，对shader重新编译不会影响整个程序，除非重新链接程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.linkProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用着色器\"><a href=\"#使用着色器\" class=\"headerlink\" title=\"使用着色器\"></a>使用着色器</h2><p>加载并使用链接好的程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.useProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用着色器画一个点\"><a href=\"#使用着色器画一个点\" class=\"headerlink\" title=\"使用着色器画一个点\"></a>使用着色器画一个点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 ,1);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>gl.clearColor()</strong>设置清空画布的颜色，参数为指定的颜色，颜色依旧采用GLES语法，颜色值范围0.0-1.1</p>\n</blockquote>\n<blockquote>\n<p><strong>gl.clear(buffer)</strong>将指定缓冲区设定为预定的值。如果清空的是颜色缓冲区，那么将使用gl.clearColor()指定值（作为预定值）</p>\n</blockquote>\n<h5 id=\"buffer可设定值\"><a href=\"#buffer可设定值\" class=\"headerlink\" title=\"buffer可设定值\"></a>buffer可设定值</h5><ul>\n<li><strong>gl.COLOR_BUFFER_BIT</strong>：指定颜色缓存</li>\n<li><strong>gl.DEPTH_BUFFER_BIT</strong>：指定深度缓冲区</li>\n<li><strong>gl.STENCIL_BUFFER_BIT</strong>：指定模板缓冲区</li>\n</ul>\n<hr>\n<h5 id=\"我们来看一看最终结果\"><a href=\"#我们来看一看最终结果\" class=\"headerlink\" title=\"我们来看一看最终结果\"></a>我们来看一看最终结果</h5><p><img src=\"/assets/img/yanglei6.jpg\" alt=\"我是图片的Alt\"></p>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>上一课将WebGL背景以及着色器一些知识简单介绍过了，本课就来讲解一下着色器具体需要怎么来编译使用才能绘制出图像。</p>\n<h3 id=\"创建WebGl与着色器编码\"><a href=\"#创建WebGl与着色器编码\" class=\"headerlink\" title=\"创建WebGl与着色器编码\"></a>创建WebGl与着色器编码</h3><p>第一步内容为第一课讲解部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">var gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建承载着色器的程序\"><a href=\"#创建承载着色器的程序\" class=\"headerlink\" title=\"创建承载着色器的程序\"></a>创建承载着色器的程序</h3><p>着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var program = gl.createProgram();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建着色器\"><a href=\"#创建着色器\" class=\"headerlink\" title=\"创建着色器\"></a>创建着色器</h3><p>使用webgl程序创建一个能承载OPENGL ES程序的容器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建顶点着色器</span><br><span class=\"line\">var vShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">//创建片元着色器</span><br><span class=\"line\">var fShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"shader容器与着色器绑定\"><a href=\"#shader容器与着色器绑定\" class=\"headerlink\" title=\"shader容器与着色器绑定\"></a>shader容器与着色器绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.shaderSource(vShader, VSHADER_SOURCE);</span><br><span class=\"line\">gl.shaderSource(fShader, FSHADER_SOURCE);</span><br></pre></td></tr></table></figure>\n<h3 id=\"将GLSE语言编译成浏览器可用代码\"><a href=\"#将GLSE语言编译成浏览器可用代码\" class=\"headerlink\" title=\"将GLSE语言编译成浏览器可用代码\"></a>将GLSE语言编译成浏览器可用代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.compileShader(vShader);</span><br><span class=\"line\">gl.compileShader(fShader);</span><br></pre></td></tr></table></figure>\n<h3 id=\"将着色器添加到程序上\"><a href=\"#将着色器添加到程序上\" class=\"headerlink\" title=\"将着色器添加到程序上\"></a>将着色器添加到程序上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.attachShader(program, vShader);</span><br><span class=\"line\">gl.attachShader(program, fShader);</span><br></pre></td></tr></table></figure>\n<h3 id=\"链接程序\"><a href=\"#链接程序\" class=\"headerlink\" title=\"链接程序\"></a>链接程序</h3><p>在链接操作执行以后，可以任意修改shader的源代码，对shader重新编译不会影响整个程序，除非重新链接程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.linkProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用着色器\"><a href=\"#使用着色器\" class=\"headerlink\" title=\"使用着色器\"></a>使用着色器</h2><p>加载并使用链接好的程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.useProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用着色器画一个点\"><a href=\"#使用着色器画一个点\" class=\"headerlink\" title=\"使用着色器画一个点\"></a>使用着色器画一个点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 ,1);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>gl.clearColor()</strong>设置清空画布的颜色，参数为指定的颜色，颜色依旧采用GLES语法，颜色值范围0.0-1.1</p>\n</blockquote>\n<blockquote>\n<p><strong>gl.clear(buffer)</strong>将指定缓冲区设定为预定的值。如果清空的是颜色缓冲区，那么将使用gl.clearColor()指定值（作为预定值）</p>\n</blockquote>\n<h5 id=\"buffer可设定值\"><a href=\"#buffer可设定值\" class=\"headerlink\" title=\"buffer可设定值\"></a>buffer可设定值</h5><ul>\n<li><strong>gl.COLOR_BUFFER_BIT</strong>：指定颜色缓存</li>\n<li><strong>gl.DEPTH_BUFFER_BIT</strong>：指定深度缓冲区</li>\n<li><strong>gl.STENCIL_BUFFER_BIT</strong>：指定模板缓冲区</li>\n</ul>\n<hr>\n<h5 id=\"我们来看一看最终结果\"><a href=\"#我们来看一看最终结果\" class=\"headerlink\" title=\"我们来看一看最终结果\"></a>我们来看一看最终结果</h5><p><img src=\"/assets/img/yanglei6.jpg\" alt=\"我是图片的Alt\"></p>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n"},{"title":"React-图片背景被键盘挤压解决方案","date":"2018-06-17T04:29:44.041Z","author":"leo","thumbnail":null,"blogexcerpt":"当背景使用background-image来设置时，Android中会出现如下事情...。","_content":"\n## 场景复现\n\n当背景使用background-image来设置时，Android中会出现如下事情：\n\n![没有键盘时](/assets/img/yanglei7-bug1.png)\n\n### 什么情况，背景图怎么变小了？\n是的，在Android中会存在这个问题，IOS中图片是不会被键盘挤压的。来看看解决办法吧。\n## 解决办法\n**在界面初始化进来时，对设置背景层的容器进行高度设置，是的，需要动态设置容器高度来保证图片不会被挤压**\n这个问题是在开发React项目时发现的，所以一下会大概写出React中解决方案。\n\n## 具体解决步骤\n\n首先，在constructor中声明一个height。\n```\nconstructor(props) {\n    super(props);\n    this.height = 0;\n}\n{% endhighlight%}\n\n第二步，在对应容器中添加style的绑定\n```\nrender() {\n    return (<div className=\"login-bg red\"  style={ {minHeight:this.height} }></div>);\n}\n```\n\n第三步：在渲染前获取屏幕高度，并设置height的值\n```\ncomponentWillMount() {\n    this.height = window.screen.height;\n}\n```\n\n**大功告成，来看看最终效果吧**\n\n![正确的情况](/assets/img/yanglei7-bug2.jpg)\n","source":"_posts/2018-01-25-yanglei7.md","raw":"---\ntitle: React-图片背景被键盘挤压解决方案\ndate: {{ date }}\nauthor: leo\ntags: react\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 当背景使用background-image来设置时，Android中会出现如下事情...。\n---\n\n## 场景复现\n\n当背景使用background-image来设置时，Android中会出现如下事情：\n\n![没有键盘时](/assets/img/yanglei7-bug1.png)\n\n### 什么情况，背景图怎么变小了？\n是的，在Android中会存在这个问题，IOS中图片是不会被键盘挤压的。来看看解决办法吧。\n## 解决办法\n**在界面初始化进来时，对设置背景层的容器进行高度设置，是的，需要动态设置容器高度来保证图片不会被挤压**\n这个问题是在开发React项目时发现的，所以一下会大概写出React中解决方案。\n\n## 具体解决步骤\n\n首先，在constructor中声明一个height。\n```\nconstructor(props) {\n    super(props);\n    this.height = 0;\n}\n{% endhighlight%}\n\n第二步，在对应容器中添加style的绑定\n```\nrender() {\n    return (<div className=\"login-bg red\"  style={ {minHeight:this.height} }></div>);\n}\n```\n\n第三步：在渲染前获取屏幕高度，并设置height的值\n```\ncomponentWillMount() {\n    this.height = window.screen.height;\n}\n```\n\n**大功告成，来看看最终效果吧**\n\n![正确的情况](/assets/img/yanglei7-bug2.jpg)\n","slug":"2018-01-25-yanglei7","published":1,"updated":"2018-06-17T07:39:44.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo58000do89kjjj686nm","content":"<h2 id=\"场景复现\"><a href=\"#场景复现\" class=\"headerlink\" title=\"场景复现\"></a>场景复现</h2><p>当背景使用background-image来设置时，Android中会出现如下事情：</p>\n<p><img src=\"/assets/img/yanglei7-bug1.png\" alt=\"没有键盘时\"></p>\n<h3 id=\"什么情况，背景图怎么变小了？\"><a href=\"#什么情况，背景图怎么变小了？\" class=\"headerlink\" title=\"什么情况，背景图怎么变小了？\"></a>什么情况，背景图怎么变小了？</h3><p>是的，在Android中会存在这个问题，IOS中图片是不会被键盘挤压的。来看看解决办法吧。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p><strong>在界面初始化进来时，对设置背景层的容器进行高度设置，是的，需要动态设置容器高度来保证图片不会被挤压</strong><br>这个问题是在开发React项目时发现的，所以一下会大概写出React中解决方案。</p>\n<h2 id=\"具体解决步骤\"><a href=\"#具体解决步骤\" class=\"headerlink\" title=\"具体解决步骤\"></a>具体解决步骤</h2><p>首先，在constructor中声明一个height。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.height = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endhighlight%&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">第二步，在对应容器中添加style的绑定</span><br></pre></td></tr></table></figure></p>\n<p>render() {<br>    return (<div classname=\"login-bg red\" style=\"{\" {minheight:this.height}=\"\" }=\"\"></div>);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第三步：在渲染前获取屏幕高度，并设置height的值</span><br></pre></td></tr></table></figure></p>\n<p>componentWillMount() {<br>    this.height = window.screen.height;<br>}<br><code>`</code></p>\n<p><strong>大功告成，来看看最终效果吧</strong></p>\n<p><img src=\"/assets/img/yanglei7-bug2.jpg\" alt=\"正确的情况\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"场景复现\"><a href=\"#场景复现\" class=\"headerlink\" title=\"场景复现\"></a>场景复现</h2><p>当背景使用background-image来设置时，Android中会出现如下事情：</p>\n<p><img src=\"/assets/img/yanglei7-bug1.png\" alt=\"没有键盘时\"></p>\n<h3 id=\"什么情况，背景图怎么变小了？\"><a href=\"#什么情况，背景图怎么变小了？\" class=\"headerlink\" title=\"什么情况，背景图怎么变小了？\"></a>什么情况，背景图怎么变小了？</h3><p>是的，在Android中会存在这个问题，IOS中图片是不会被键盘挤压的。来看看解决办法吧。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p><strong>在界面初始化进来时，对设置背景层的容器进行高度设置，是的，需要动态设置容器高度来保证图片不会被挤压</strong><br>这个问题是在开发React项目时发现的，所以一下会大概写出React中解决方案。</p>\n<h2 id=\"具体解决步骤\"><a href=\"#具体解决步骤\" class=\"headerlink\" title=\"具体解决步骤\"></a>具体解决步骤</h2><p>首先，在constructor中声明一个height。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.height = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endhighlight%&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">第二步，在对应容器中添加style的绑定</span><br></pre></td></tr></table></figure></p>\n<p>render() {<br>    return (<div classname=\"login-bg red\" style=\"{\" {minheight:this.height}=\"\" }=\"\"></div>);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第三步：在渲染前获取屏幕高度，并设置height的值</span><br></pre></td></tr></table></figure></p>\n<p>componentWillMount() {<br>    this.height = window.screen.height;<br>}<br><code>`</code></p>\n<p><strong>大功告成，来看看最终效果吧</strong></p>\n<p><img src=\"/assets/img/yanglei7-bug2.jpg\" alt=\"正确的情况\"></p>\n"},{"title":"WebGL第三课-着色器编程","date":"2018-06-17T04:29:44.041Z","author":"leo","thumbnail":null,"blogexcerpt":"前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?","_content":"\n## 着色器编程\n前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?\n\n## 代码顺序\n在对着色器编程时，需要先将program连接到WebGL中，以及需要program使用之后才可编辑。\n#### 介绍2个变量\n\n- attribute： 用于顶点点着色器（**Vertex Shader**）传值时使用。\n- uniform：可用于顶点着色器（**Vertex Shader**）与片元着色器（**Fragment Shader**）使用。\n\n## 将顶点动态化\n首先，先在顶点着色器代码中，将对应的vec4的固定值变成变量\n```\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n位置参数使用了**attribute**变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。\n\n使用WebGL来获取对应参数的存储地址地址\n```\n//返回对应的地址信息\nvar aPosition = gl.getAttribLocation(gl.program, 'a_Position');\n//判断地址是否获取成功\nif(aPosition < 0) {\n    console.log('没有获取到对应position');\n}\n```\n\n然后给变量赋值\n```\ngl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);\n//或者使用Float32Array来传参\nvar p = new Float32Array([1.0, 1.0, 1.0]);\ngl.vertexAttrib3fv(aPosition, p);\n```\n\n    注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\n    vertexAttrib函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    v：表示传如的为一个vector变量。\n\n也就是说对应设置顶点着色器的函数有一下几种功能，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a>**：\n\n- void gl.vertexAttrib1f(index, v0);\n- void gl.vertexAttrib2f(index, v0, v1);\n- void gl.vertexAttrib3f(index, v0, v1, v2);\n- void gl.vertexAttrib4f(index, v0, v1, v2, v3);\n\n- void gl.vertexAttrib1fv(index, value);\n- void gl.vertexAttrib2fv(index, value);\n- void gl.vertexAttrib3fv(index, value);\n- void gl.vertexAttrib4fv(index, value);\n\n同样操作可以如下修改PointSize：\n```\n//着色器中添加变量\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'attribute float a_PointSize;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = a_PointSize;\\n' + \n  '}\\n';\nvar aPointSize = gl.getAttribLocation(gl.program, 'a_PointSize');\ngl.vertexAttrib1f(aPointSize, 10.0);\n```\n\n## 片元着色器编程\n对片元着色器变成需要使用uniform变量来承载。\n```\n var FSHADER_SOURCE =\n'precision mediump float;\\n'+\n'uniform vec4 vColor;\\n'+\n'void main() {\\n' +\n'  gl_FragColor = vColor;\\n' + // Set the point color\n'}\\n';\n```\n获取片元着色器变量地址\n```\nvar vColor = gl.getUniformLocation(gl.program, 'vColor');\n```\n给变量赋值\n```\ngl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);\n//或使用Float32Array来传参\nvar color = new Float32Array([1.0, 0.0, 0.0, 1.0]);\ngl.uniform4fv(vColor,color)\n```\n\n    注意：uniform3fv这个函数是典型的GLSL语法命名规范，\n    uniform3fv函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    u：表示参数是Uint32Array类型，\n    i：表示参数是integer类型，\n    ui：表示参数是unsigned integer类型，\n    v：表示传如的为一个vector变量。\n\n\n顶点着色器对应函数，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a>**\n- void gl.uniform1ui(location, v0); \n- void gl.uniform2ui(location, v0, v1); \n- void gl.uniform3ui(location, v0, v1, v2); \n- void gl.uniform4ui(location, v0, v1, v2, v3); \n- void gl.uniform1fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform2fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform3fv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform4fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform1iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform2iv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform3iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform4iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform1uiv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform2uiv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform3uiv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform4uiv(location, data, optional srcOffset, optional srcLength);\n\n>着色器中的代码**precision mediump float;**表示的意思是着色器中配置的float对象会占用中等尺寸内存。\n具体包含的尺寸：\n- highp for vertex positions,\n- mediump for texture coordinates,\n- lowp for colors.\n\n如果不设置此参数会报错：\n![我是图片的Alt](/assets/img/yanglei8.jpg)\n\n最终动态效果图：\n![我是图片的Alt](/assets/img/yanglei8-1.png)\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>","source":"_posts/2018-02-05-yanglei8.md","raw":"---\ntitle: WebGL第三课-着色器编程\ndate: {{ date }}\nauthor: leo\ntags: WebGL\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?\n---\n\n## 着色器编程\n前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?\n\n## 代码顺序\n在对着色器编程时，需要先将program连接到WebGL中，以及需要program使用之后才可编辑。\n#### 介绍2个变量\n\n- attribute： 用于顶点点着色器（**Vertex Shader**）传值时使用。\n- uniform：可用于顶点着色器（**Vertex Shader**）与片元着色器（**Fragment Shader**）使用。\n\n## 将顶点动态化\n首先，先在顶点着色器代码中，将对应的vec4的固定值变成变量\n```\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n位置参数使用了**attribute**变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。\n\n使用WebGL来获取对应参数的存储地址地址\n```\n//返回对应的地址信息\nvar aPosition = gl.getAttribLocation(gl.program, 'a_Position');\n//判断地址是否获取成功\nif(aPosition < 0) {\n    console.log('没有获取到对应position');\n}\n```\n\n然后给变量赋值\n```\ngl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);\n//或者使用Float32Array来传参\nvar p = new Float32Array([1.0, 1.0, 1.0]);\ngl.vertexAttrib3fv(aPosition, p);\n```\n\n    注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\n    vertexAttrib函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    v：表示传如的为一个vector变量。\n\n也就是说对应设置顶点着色器的函数有一下几种功能，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a>**：\n\n- void gl.vertexAttrib1f(index, v0);\n- void gl.vertexAttrib2f(index, v0, v1);\n- void gl.vertexAttrib3f(index, v0, v1, v2);\n- void gl.vertexAttrib4f(index, v0, v1, v2, v3);\n\n- void gl.vertexAttrib1fv(index, value);\n- void gl.vertexAttrib2fv(index, value);\n- void gl.vertexAttrib3fv(index, value);\n- void gl.vertexAttrib4fv(index, value);\n\n同样操作可以如下修改PointSize：\n```\n//着色器中添加变量\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'attribute float a_PointSize;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = a_PointSize;\\n' + \n  '}\\n';\nvar aPointSize = gl.getAttribLocation(gl.program, 'a_PointSize');\ngl.vertexAttrib1f(aPointSize, 10.0);\n```\n\n## 片元着色器编程\n对片元着色器变成需要使用uniform变量来承载。\n```\n var FSHADER_SOURCE =\n'precision mediump float;\\n'+\n'uniform vec4 vColor;\\n'+\n'void main() {\\n' +\n'  gl_FragColor = vColor;\\n' + // Set the point color\n'}\\n';\n```\n获取片元着色器变量地址\n```\nvar vColor = gl.getUniformLocation(gl.program, 'vColor');\n```\n给变量赋值\n```\ngl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);\n//或使用Float32Array来传参\nvar color = new Float32Array([1.0, 0.0, 0.0, 1.0]);\ngl.uniform4fv(vColor,color)\n```\n\n    注意：uniform3fv这个函数是典型的GLSL语法命名规范，\n    uniform3fv函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    u：表示参数是Uint32Array类型，\n    i：表示参数是integer类型，\n    ui：表示参数是unsigned integer类型，\n    v：表示传如的为一个vector变量。\n\n\n顶点着色器对应函数，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a>**\n- void gl.uniform1ui(location, v0); \n- void gl.uniform2ui(location, v0, v1); \n- void gl.uniform3ui(location, v0, v1, v2); \n- void gl.uniform4ui(location, v0, v1, v2, v3); \n- void gl.uniform1fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform2fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform3fv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform4fv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform1iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform2iv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform3iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform4iv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform1uiv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform2uiv(location, data, optional srcOffset, optional srcLength);\n- void gl.uniform3uiv(location, data, optional srcOffset, optional srcLength); \n- void gl.uniform4uiv(location, data, optional srcOffset, optional srcLength);\n\n>着色器中的代码**precision mediump float;**表示的意思是着色器中配置的float对象会占用中等尺寸内存。\n具体包含的尺寸：\n- highp for vertex positions,\n- mediump for texture coordinates,\n- lowp for colors.\n\n如果不设置此参数会报错：\n![我是图片的Alt](/assets/img/yanglei8.jpg)\n\n最终动态效果图：\n![我是图片的Alt](/assets/img/yanglei8-1.png)\n\n---\n\n#### Webgl课程列表\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a>\n- <a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a>","slug":"2018-02-05-yanglei8","published":1,"updated":"2018-06-17T07:40:25.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo5b000io89kcn03xhy9","content":"<h2 id=\"着色器编程\"><a href=\"#着色器编程\" class=\"headerlink\" title=\"着色器编程\"></a>着色器编程</h2><p>前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?</p>\n<h2 id=\"代码顺序\"><a href=\"#代码顺序\" class=\"headerlink\" title=\"代码顺序\"></a>代码顺序</h2><p>在对着色器编程时，需要先将program连接到WebGL中，以及需要program使用之后才可编辑。</p>\n<h4 id=\"介绍2个变量\"><a href=\"#介绍2个变量\" class=\"headerlink\" title=\"介绍2个变量\"></a>介绍2个变量</h4><ul>\n<li>attribute： 用于顶点点着色器（<strong>Vertex Shader</strong>）传值时使用。</li>\n<li>uniform：可用于顶点着色器（<strong>Vertex Shader</strong>）与片元着色器（<strong>Fragment Shader</strong>）使用。</li>\n</ul>\n<h2 id=\"将顶点动态化\"><a href=\"#将顶点动态化\" class=\"headerlink\" title=\"将顶点动态化\"></a>将顶点动态化</h2><p>首先，先在顶点着色器代码中，将对应的vec4的固定值变成变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>位置参数使用了<strong>attribute</strong>变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。</p>\n<p>使用WebGL来获取对应参数的存储地址地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回对应的地址信息</span><br><span class=\"line\">var aPosition = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//判断地址是否获取成功</span><br><span class=\"line\">if(aPosition &lt; 0) &#123;</span><br><span class=\"line\">    console.log(&apos;没有获取到对应position&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);</span><br><span class=\"line\">//或者使用Float32Array来传参</span><br><span class=\"line\">var p = new Float32Array([1.0, 1.0, 1.0]);</span><br><span class=\"line\">gl.vertexAttrib3fv(aPosition, p);</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\nvertexAttrib函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>也就是说对应设置顶点着色器的函数有一下几种功能，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a></strong>：</p>\n<ul>\n<li>void gl.vertexAttrib1f(index, v0);</li>\n<li>void gl.vertexAttrib2f(index, v0, v1);</li>\n<li>void gl.vertexAttrib3f(index, v0, v1, v2);</li>\n<li><p>void gl.vertexAttrib4f(index, v0, v1, v2, v3);</p>\n</li>\n<li><p>void gl.vertexAttrib1fv(index, value);</p>\n</li>\n<li>void gl.vertexAttrib2fv(index, value);</li>\n<li>void gl.vertexAttrib3fv(index, value);</li>\n<li>void gl.vertexAttrib4fv(index, value);</li>\n</ul>\n<p>同样操作可以如下修改PointSize：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//着色器中添加变量</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;attribute float a_PointSize;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = a_PointSize;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var aPointSize = gl.getAttribLocation(gl.program, &apos;a_PointSize&apos;);</span><br><span class=\"line\">gl.vertexAttrib1f(aPointSize, 10.0);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"片元着色器编程\"><a href=\"#片元着色器编程\" class=\"headerlink\" title=\"片元着色器编程\"></a>片元着色器编程</h2><p>对片元着色器变成需要使用uniform变量来承载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">&apos;precision mediump float;\\n&apos;+</span><br><span class=\"line\">&apos;uniform vec4 vColor;\\n&apos;+</span><br><span class=\"line\">&apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">&apos;  gl_FragColor = vColor;\\n&apos; + // Set the point color</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>获取片元着色器变量地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vColor = gl.getUniformLocation(gl.program, &apos;vColor&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">//或使用Float32Array来传参</span><br><span class=\"line\">var color = new Float32Array([1.0, 0.0, 0.0, 1.0]);</span><br><span class=\"line\">gl.uniform4fv(vColor,color)</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：uniform3fv这个函数是典型的GLSL语法命名规范，\nuniform3fv函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nu：表示参数是Uint32Array类型，\ni：表示参数是integer类型，\nui：表示参数是unsigned integer类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>顶点着色器对应函数，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a></strong></p>\n<ul>\n<li>void gl.uniform1ui(location, v0); </li>\n<li>void gl.uniform2ui(location, v0, v1); </li>\n<li>void gl.uniform3ui(location, v0, v1, v2); </li>\n<li>void gl.uniform4ui(location, v0, v1, v2, v3); </li>\n<li>void gl.uniform1fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform2fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform3fv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform4fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform1iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform2iv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform3iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform4iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform1uiv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform2uiv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform3uiv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform4uiv(location, data, optional srcOffset, optional srcLength);</li>\n</ul>\n<blockquote>\n<p>着色器中的代码<strong>precision mediump float;</strong>表示的意思是着色器中配置的float对象会占用中等尺寸内存。<br>具体包含的尺寸：</p>\n<ul>\n<li>highp for vertex positions,</li>\n<li>mediump for texture coordinates,</li>\n<li>lowp for colors.</li>\n</ul>\n</blockquote>\n<p>如果不设置此参数会报错：<br><img src=\"/assets/img/yanglei8.jpg\" alt=\"我是图片的Alt\"></p>\n<p>最终动态效果图：<br><img src=\"/assets/img/yanglei8-1.png\" alt=\"我是图片的Alt\"></p>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"着色器编程\"><a href=\"#着色器编程\" class=\"headerlink\" title=\"着色器编程\"></a>着色器编程</h2><p>前2课已经将了如果使用顶点着色器以及片元着色器来绘制点，但是真实情况下是不会存在固定颜色与尺寸位置的，如何对他们进行编码呢?</p>\n<h2 id=\"代码顺序\"><a href=\"#代码顺序\" class=\"headerlink\" title=\"代码顺序\"></a>代码顺序</h2><p>在对着色器编程时，需要先将program连接到WebGL中，以及需要program使用之后才可编辑。</p>\n<h4 id=\"介绍2个变量\"><a href=\"#介绍2个变量\" class=\"headerlink\" title=\"介绍2个变量\"></a>介绍2个变量</h4><ul>\n<li>attribute： 用于顶点点着色器（<strong>Vertex Shader</strong>）传值时使用。</li>\n<li>uniform：可用于顶点着色器（<strong>Vertex Shader</strong>）与片元着色器（<strong>Fragment Shader</strong>）使用。</li>\n</ul>\n<h2 id=\"将顶点动态化\"><a href=\"#将顶点动态化\" class=\"headerlink\" title=\"将顶点动态化\"></a>将顶点动态化</h2><p>首先，先在顶点着色器代码中，将对应的vec4的固定值变成变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>位置参数使用了<strong>attribute</strong>变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。</p>\n<p>使用WebGL来获取对应参数的存储地址地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回对应的地址信息</span><br><span class=\"line\">var aPosition = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//判断地址是否获取成功</span><br><span class=\"line\">if(aPosition &lt; 0) &#123;</span><br><span class=\"line\">    console.log(&apos;没有获取到对应position&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);</span><br><span class=\"line\">//或者使用Float32Array来传参</span><br><span class=\"line\">var p = new Float32Array([1.0, 1.0, 1.0]);</span><br><span class=\"line\">gl.vertexAttrib3fv(aPosition, p);</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\nvertexAttrib函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>也就是说对应设置顶点着色器的函数有一下几种功能，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a></strong>：</p>\n<ul>\n<li>void gl.vertexAttrib1f(index, v0);</li>\n<li>void gl.vertexAttrib2f(index, v0, v1);</li>\n<li>void gl.vertexAttrib3f(index, v0, v1, v2);</li>\n<li><p>void gl.vertexAttrib4f(index, v0, v1, v2, v3);</p>\n</li>\n<li><p>void gl.vertexAttrib1fv(index, value);</p>\n</li>\n<li>void gl.vertexAttrib2fv(index, value);</li>\n<li>void gl.vertexAttrib3fv(index, value);</li>\n<li>void gl.vertexAttrib4fv(index, value);</li>\n</ul>\n<p>同样操作可以如下修改PointSize：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//着色器中添加变量</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;attribute float a_PointSize;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = a_PointSize;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var aPointSize = gl.getAttribLocation(gl.program, &apos;a_PointSize&apos;);</span><br><span class=\"line\">gl.vertexAttrib1f(aPointSize, 10.0);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"片元着色器编程\"><a href=\"#片元着色器编程\" class=\"headerlink\" title=\"片元着色器编程\"></a>片元着色器编程</h2><p>对片元着色器变成需要使用uniform变量来承载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">&apos;precision mediump float;\\n&apos;+</span><br><span class=\"line\">&apos;uniform vec4 vColor;\\n&apos;+</span><br><span class=\"line\">&apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">&apos;  gl_FragColor = vColor;\\n&apos; + // Set the point color</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>获取片元着色器变量地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vColor = gl.getUniformLocation(gl.program, &apos;vColor&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">//或使用Float32Array来传参</span><br><span class=\"line\">var color = new Float32Array([1.0, 0.0, 0.0, 1.0]);</span><br><span class=\"line\">gl.uniform4fv(vColor,color)</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：uniform3fv这个函数是典型的GLSL语法命名规范，\nuniform3fv函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nu：表示参数是Uint32Array类型，\ni：表示参数是integer类型，\nui：表示参数是unsigned integer类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>顶点着色器对应函数，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a></strong></p>\n<ul>\n<li>void gl.uniform1ui(location, v0); </li>\n<li>void gl.uniform2ui(location, v0, v1); </li>\n<li>void gl.uniform3ui(location, v0, v1, v2); </li>\n<li>void gl.uniform4ui(location, v0, v1, v2, v3); </li>\n<li>void gl.uniform1fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform2fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform3fv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform4fv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform1iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform2iv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform3iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform4iv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform1uiv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform2uiv(location, data, optional srcOffset, optional srcLength);</li>\n<li>void gl.uniform3uiv(location, data, optional srcOffset, optional srcLength); </li>\n<li>void gl.uniform4uiv(location, data, optional srcOffset, optional srcLength);</li>\n</ul>\n<blockquote>\n<p>着色器中的代码<strong>precision mediump float;</strong>表示的意思是着色器中配置的float对象会占用中等尺寸内存。<br>具体包含的尺寸：</p>\n<ul>\n<li>highp for vertex positions,</li>\n<li>mediump for texture coordinates,</li>\n<li>lowp for colors.</li>\n</ul>\n</blockquote>\n<p>如果不设置此参数会报错：<br><img src=\"/assets/img/yanglei8.jpg\" alt=\"我是图片的Alt\"></p>\n<p>最终动态效果图：<br><img src=\"/assets/img/yanglei8-1.png\" alt=\"我是图片的Alt\"></p>\n<hr>\n<h4 id=\"Webgl课程列表\"><a href=\"#Webgl课程列表\" class=\"headerlink\" title=\"Webgl课程列表\"></a>Webgl课程列表</h4><ul>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei5.html\">[WebGL第一课-基础介绍]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei6.html\">[WebGL第二课-着色器使用]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei8.html\">[WebGL第三课-着色器编程]</a></li>\n<li><a target=\"_blank\" href=\"/yanglei/2018/01/24/yanglei9.html\">[WebGL第四课-图像缓存区使用]</a></li>\n</ul>\n"},{"title":"WebGL第四课-图像缓存区使用","date":"2018-06-17T04:29:44.042Z","author":"leo","thumbnail":null,"blogexcerpt":"前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。","_content":"\n前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。\n\n之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：***缓存区对象（buffer data）***,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。\n\n## 使用缓存区步骤\n- 创建缓存区对象(gl.createBuffer())\n- 绑定缓存区对象(gl.bindBuffer())\n- 将数据写入缓存区对象(gl.bufferData())\n- 将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())\n- 开启attribute变量(gl.enableVertexAttribArray())\n\n## 具体创建过程\n首先，我们仍然需要创建WebGL对象、片元着色器以及顶点着色器，具体创建的步骤以及原理，可参考之前的教程。具体代码实现如下：\n```\n<!-- 书写着色器代码 -->\nvar v_Shader = `\n    attribute vec4 a_p;\n    void main() {\n        gl_Position = a_p;\n        gl_PointSize = 10.0;\n    }\n`;\nvar f_Shader = `\n    void main(){\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n`;\n<!-- 创建WebGL -->\nvar canvas = document.getElementById(id);\ngl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n<!-- 创建片元操作程序 -->\nvar program = gl.createProgram();\n\n<!-- 创建片元着色器 -->\nvar fsShader = gl.createShader(gl.FRAGMENT_SHADER);\n<!-- 着色器对象绑定着色器代码 -->\ngl.shaderSource(fsShader, f_Shader);\n<!-- GLSE语法编译成js语法 -->\ngl.compileShader(fsShader);\n\n<!-- 创建顶点着色器 -->\nvar vsShader = gl.createShader(gl.VERTEX_SHADER);\n<!-- 着色器对象绑定着色器代码 -->\ngl.shaderSource(vsShader, v_Shader);\n<!-- GLSE语法编译成js语法 -->\ngl.compileShader(vsShader);\n\n<!-- 运行程序绑定着色器-->\ngl.attachShader(program, vsShader);\ngl.attachShader(program, fsShader);\n<!-- WebGL与program建立连接 -->\ngl.linkProgram(program);\n<!-- 使用此program -->\ngl.useProgram(program);\n\n<!-- 初始化WebGL已经完成 -->\n```\n\n当创建好WebGL之后，可以通过着色器中的attrbute或者uniform对象来传递需要动态修改或设置的的变量。\n\n接下来我们需要进行缓冲区的操作：\n首先，需要创建一个缓冲区来承载大量顶点的坐标\n（代码继续上文）\n```\n<!-- 创建缓存区 -->\nvar vertexBuffer = gl.createBuffer();\nif(!vertexBuffer) {\n    log('创建缓存区失败。');\n    return -1;\n}\n<!-- 将创建的缓存区对象绑定到target表示的目标上 -->\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n<!-- 开辟存储空间，向绑定在target上的缓存区对象中写入数据 -->\ngl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n<!-- 获取着色器中的变量值 -->\nvar a_position = gl.getAttribLocation(gl.program, 'a_p');\n<!-- 将缓存区对象绑定到着色器变量中 -->\ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n<!-- 启用缓存区 -->\ngl.enableVertexAttribArray(a_position);\n<!-- 绘制缓存区中画的多个顶点 -->\ngl.drawArrays(gl.POINTS, 0 , array);\n```\n\n看完了绘制过程，让我们来拆解一下具体内容：\n\n首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，***bingBuffer***就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。\n### <a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a>\n\n***target: 指定存储缓存区的目标类型***\n- gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据\n- gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值\n\n***buffer: 自己创建的缓存区对象***\n\n接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用***Float32Array***类型来创建支持GLSL的数据。使用***bufferData***函数将数据放入缓存区内。\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a>\n\n***target: 同上***\n\n***size: 为多个顶点坐标的集合数组***\n\n***usage: 表示程序将如何使用缓存区中的数据***\n- gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次\n- gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次\n- gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次\n\n缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中***getAttribLocation***函数获取着色器中的attribute类型变量，并且通过***vertexAttribPointer***将其赋值改变，从而达到改变图像呈现。\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a>\n\n***param: webgl之前创建的进程***\n\n***name: 变量名称***\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a>\n\n***name: 指定要赋值的attribute变量位置***\n\n***size: 指定每个顶点数据的分量个数（1或4）***\n\n***type: 指定传入的数据格式***\n- gl.BYTE: 字节型, 取值范围[-128, 127]\n- gl.SHORT: 短整型,取值范围[-32768, 32767]\n- gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]\n- gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]\n- gl.FLOAT: 浮点型\n\n***normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间***\n\n\n***stride: 指定相邻2个顶点间的字节数，默认为0***\n\n\n***offset: 指定缓存区对象中的偏移量，设置为0即可***\n```\n如为2，则\nnew Float32Array([\n    1.0, 1.0,\n    1.0,1.0\n])\n代表2个顶点\n如为4，则\nnew Float32Array([\n    1.0, 1.0, 1.0,1.0\n])\n代表1个顶点\n```\n\n现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用***enableVertexAttribArray***来启用对应变量。\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a>\n\n***name: 待启动的变量指针，也就是名称***\n\n所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a>\n\n***mode: 需要绘制的图像形状***\n- gl.POINTS: 绘制一个点。\n- gl.LINE_STRIP: 绘制一条直线到下一个顶点。\n- gl.LINE_LOOP: 绘制一条首尾相连的线。\n- gl.LINES: 绘制一条线。\n- gl.TRIANGLES: 绘制一个三角形。\n\n***first: 绘制的开始点***\n\n***count: 需要绘制的图形个数***\n\n看看屏幕吧，是不是出来了好多点。","source":"_posts/2018-03-13-yanglei9.md","raw":"---\ntitle: WebGL第四课-图像缓存区使用\ndate: {{ date }}\nauthor: leo\ntags: WebGL\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。\n---\n\n前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。\n\n之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：***缓存区对象（buffer data）***,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。\n\n## 使用缓存区步骤\n- 创建缓存区对象(gl.createBuffer())\n- 绑定缓存区对象(gl.bindBuffer())\n- 将数据写入缓存区对象(gl.bufferData())\n- 将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())\n- 开启attribute变量(gl.enableVertexAttribArray())\n\n## 具体创建过程\n首先，我们仍然需要创建WebGL对象、片元着色器以及顶点着色器，具体创建的步骤以及原理，可参考之前的教程。具体代码实现如下：\n```\n<!-- 书写着色器代码 -->\nvar v_Shader = `\n    attribute vec4 a_p;\n    void main() {\n        gl_Position = a_p;\n        gl_PointSize = 10.0;\n    }\n`;\nvar f_Shader = `\n    void main(){\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n`;\n<!-- 创建WebGL -->\nvar canvas = document.getElementById(id);\ngl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n<!-- 创建片元操作程序 -->\nvar program = gl.createProgram();\n\n<!-- 创建片元着色器 -->\nvar fsShader = gl.createShader(gl.FRAGMENT_SHADER);\n<!-- 着色器对象绑定着色器代码 -->\ngl.shaderSource(fsShader, f_Shader);\n<!-- GLSE语法编译成js语法 -->\ngl.compileShader(fsShader);\n\n<!-- 创建顶点着色器 -->\nvar vsShader = gl.createShader(gl.VERTEX_SHADER);\n<!-- 着色器对象绑定着色器代码 -->\ngl.shaderSource(vsShader, v_Shader);\n<!-- GLSE语法编译成js语法 -->\ngl.compileShader(vsShader);\n\n<!-- 运行程序绑定着色器-->\ngl.attachShader(program, vsShader);\ngl.attachShader(program, fsShader);\n<!-- WebGL与program建立连接 -->\ngl.linkProgram(program);\n<!-- 使用此program -->\ngl.useProgram(program);\n\n<!-- 初始化WebGL已经完成 -->\n```\n\n当创建好WebGL之后，可以通过着色器中的attrbute或者uniform对象来传递需要动态修改或设置的的变量。\n\n接下来我们需要进行缓冲区的操作：\n首先，需要创建一个缓冲区来承载大量顶点的坐标\n（代码继续上文）\n```\n<!-- 创建缓存区 -->\nvar vertexBuffer = gl.createBuffer();\nif(!vertexBuffer) {\n    log('创建缓存区失败。');\n    return -1;\n}\n<!-- 将创建的缓存区对象绑定到target表示的目标上 -->\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n<!-- 开辟存储空间，向绑定在target上的缓存区对象中写入数据 -->\ngl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n<!-- 获取着色器中的变量值 -->\nvar a_position = gl.getAttribLocation(gl.program, 'a_p');\n<!-- 将缓存区对象绑定到着色器变量中 -->\ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n<!-- 启用缓存区 -->\ngl.enableVertexAttribArray(a_position);\n<!-- 绘制缓存区中画的多个顶点 -->\ngl.drawArrays(gl.POINTS, 0 , array);\n```\n\n看完了绘制过程，让我们来拆解一下具体内容：\n\n首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，***bingBuffer***就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。\n### <a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a>\n\n***target: 指定存储缓存区的目标类型***\n- gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据\n- gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值\n\n***buffer: 自己创建的缓存区对象***\n\n接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用***Float32Array***类型来创建支持GLSL的数据。使用***bufferData***函数将数据放入缓存区内。\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a>\n\n***target: 同上***\n\n***size: 为多个顶点坐标的集合数组***\n\n***usage: 表示程序将如何使用缓存区中的数据***\n- gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次\n- gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次\n- gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次\n\n缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中***getAttribLocation***函数获取着色器中的attribute类型变量，并且通过***vertexAttribPointer***将其赋值改变，从而达到改变图像呈现。\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a>\n\n***param: webgl之前创建的进程***\n\n***name: 变量名称***\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a>\n\n***name: 指定要赋值的attribute变量位置***\n\n***size: 指定每个顶点数据的分量个数（1或4）***\n\n***type: 指定传入的数据格式***\n- gl.BYTE: 字节型, 取值范围[-128, 127]\n- gl.SHORT: 短整型,取值范围[-32768, 32767]\n- gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]\n- gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]\n- gl.FLOAT: 浮点型\n\n***normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间***\n\n\n***stride: 指定相邻2个顶点间的字节数，默认为0***\n\n\n***offset: 指定缓存区对象中的偏移量，设置为0即可***\n```\n如为2，则\nnew Float32Array([\n    1.0, 1.0,\n    1.0,1.0\n])\n代表2个顶点\n如为4，则\nnew Float32Array([\n    1.0, 1.0, 1.0,1.0\n])\n代表1个顶点\n```\n\n现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用***enableVertexAttribArray***来启用对应变量。\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a>\n\n***name: 待启动的变量指针，也就是名称***\n\n所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点\n\n### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a>\n\n***mode: 需要绘制的图像形状***\n- gl.POINTS: 绘制一个点。\n- gl.LINE_STRIP: 绘制一条直线到下一个顶点。\n- gl.LINE_LOOP: 绘制一条首尾相连的线。\n- gl.LINES: 绘制一条线。\n- gl.TRIANGLES: 绘制一个三角形。\n\n***first: 绘制的开始点***\n\n***count: 需要绘制的图形个数***\n\n看看屏幕吧，是不是出来了好多点。","slug":"2018-03-13-yanglei9","published":1,"updated":"2018-06-17T07:40:50.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo5d000lo89khz2m6wxi","content":"<p>前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。</p>\n<p>之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：<strong><em>缓存区对象（buffer data）</em></strong>,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。</p>\n<h2 id=\"使用缓存区步骤\"><a href=\"#使用缓存区步骤\" class=\"headerlink\" title=\"使用缓存区步骤\"></a>使用缓存区步骤</h2><ul>\n<li>创建缓存区对象(gl.createBuffer())</li>\n<li>绑定缓存区对象(gl.bindBuffer())</li>\n<li>将数据写入缓存区对象(gl.bufferData())</li>\n<li>将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())</li>\n<li>开启attribute变量(gl.enableVertexAttribArray())</li>\n</ul>\n<h2 id=\"具体创建过程\"><a href=\"#具体创建过程\" class=\"headerlink\" title=\"具体创建过程\"></a>具体创建过程</h2><p>首先，我们仍然需要创建WebGL对象、片元着色器以及顶点着色器，具体创建的步骤以及原理，可参考之前的教程。具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 书写着色器代码 --&gt;</span><br><span class=\"line\">var v_Shader = `</span><br><span class=\"line\">    attribute vec4 a_p;</span><br><span class=\"line\">    void main() &#123;</span><br><span class=\"line\">        gl_Position = a_p;</span><br><span class=\"line\">        gl_PointSize = 10.0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">`;</span><br><span class=\"line\">var f_Shader = `</span><br><span class=\"line\">    void main()&#123;</span><br><span class=\"line\">        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">`;</span><br><span class=\"line\">&lt;!-- 创建WebGL --&gt;</span><br><span class=\"line\">var canvas = document.getElementById(id);</span><br><span class=\"line\">gl = canvas.getContext(&apos;webgl&apos;) || canvas.getContext(&apos;experimental-webgl&apos;);</span><br><span class=\"line\">&lt;!-- 创建片元操作程序 --&gt;</span><br><span class=\"line\">var program = gl.createProgram();</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 创建片元着色器 --&gt;</span><br><span class=\"line\">var fsShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class=\"line\">&lt;!-- 着色器对象绑定着色器代码 --&gt;</span><br><span class=\"line\">gl.shaderSource(fsShader, f_Shader);</span><br><span class=\"line\">&lt;!-- GLSE语法编译成js语法 --&gt;</span><br><span class=\"line\">gl.compileShader(fsShader);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 创建顶点着色器 --&gt;</span><br><span class=\"line\">var vsShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">&lt;!-- 着色器对象绑定着色器代码 --&gt;</span><br><span class=\"line\">gl.shaderSource(vsShader, v_Shader);</span><br><span class=\"line\">&lt;!-- GLSE语法编译成js语法 --&gt;</span><br><span class=\"line\">gl.compileShader(vsShader);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 运行程序绑定着色器--&gt;</span><br><span class=\"line\">gl.attachShader(program, vsShader);</span><br><span class=\"line\">gl.attachShader(program, fsShader);</span><br><span class=\"line\">&lt;!-- WebGL与program建立连接 --&gt;</span><br><span class=\"line\">gl.linkProgram(program);</span><br><span class=\"line\">&lt;!-- 使用此program --&gt;</span><br><span class=\"line\">gl.useProgram(program);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 初始化WebGL已经完成 --&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当创建好WebGL之后，可以通过着色器中的attrbute或者uniform对象来传递需要动态修改或设置的的变量。</p>\n<p>接下来我们需要进行缓冲区的操作：<br>首先，需要创建一个缓冲区来承载大量顶点的坐标<br>（代码继续上文）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 创建缓存区 --&gt;</span><br><span class=\"line\">var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">if(!vertexBuffer) &#123;</span><br><span class=\"line\">    log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!-- 将创建的缓存区对象绑定到target表示的目标上 --&gt;</span><br><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">&lt;!-- 开辟存储空间，向绑定在target上的缓存区对象中写入数据 --&gt;</span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">&lt;!-- 获取着色器中的变量值 --&gt;</span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">&lt;!-- 将缓存区对象绑定到着色器变量中 --&gt;</span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">&lt;!-- 启用缓存区 --&gt;</span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">&lt;!-- 绘制缓存区中画的多个顶点 --&gt;</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , array);</span><br></pre></td></tr></table></figure></p>\n<p>看完了绘制过程，让我们来拆解一下具体内容：</p>\n<p>首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，<strong><em>bingBuffer</em></strong>就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。</p>\n<h3 id=\"gl-bindBuffer-target-buffer\"><a href=\"#gl-bindBuffer-target-buffer\" class=\"headerlink\" title=\"gl.bindBuffer(target, buffer)\"></a><a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a></h3><p><strong><em>target: 指定存储缓存区的目标类型</em></strong></p>\n<ul>\n<li>gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据</li>\n<li>gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值</li>\n</ul>\n<p><strong><em>buffer: 自己创建的缓存区对象</em></strong></p>\n<p>接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用<strong><em>Float32Array</em></strong>类型来创建支持GLSL的数据。使用<strong><em>bufferData</em></strong>函数将数据放入缓存区内。</p>\n<h3 id=\"gl-bufferData-target-size-usage\"><a href=\"#gl-bufferData-target-size-usage\" class=\"headerlink\" title=\"gl.bufferData(target, size, usage)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a></h3><p><strong><em>target: 同上</em></strong></p>\n<p><strong><em>size: 为多个顶点坐标的集合数组</em></strong></p>\n<p><strong><em>usage: 表示程序将如何使用缓存区中的数据</em></strong></p>\n<ul>\n<li>gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次</li>\n<li>gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次</li>\n<li>gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次</li>\n</ul>\n<p>缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中<strong><em>getAttribLocation</em></strong>函数获取着色器中的attribute类型变量，并且通过<strong><em>vertexAttribPointer</em></strong>将其赋值改变，从而达到改变图像呈现。</p>\n<h3 id=\"gl-getAttribLocation-program-name\"><a href=\"#gl-getAttribLocation-program-name\" class=\"headerlink\" title=\"gl.getAttribLocation(program,name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a></h3><p><strong><em>param: webgl之前创建的进程</em></strong></p>\n<p><strong><em>name: 变量名称</em></strong></p>\n<h3 id=\"gl-vertexAttribPointer-name-size-type-normalized-stride-offset\"><a href=\"#gl-vertexAttribPointer-name-size-type-normalized-stride-offset\" class=\"headerlink\" title=\"gl.vertexAttribPointer(name, size, type, normalized, stride, offset)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a></h3><p><strong><em>name: 指定要赋值的attribute变量位置</em></strong></p>\n<p><strong><em>size: 指定每个顶点数据的分量个数（1或4）</em></strong></p>\n<p><strong><em>type: 指定传入的数据格式</em></strong></p>\n<ul>\n<li>gl.BYTE: 字节型, 取值范围[-128, 127]</li>\n<li>gl.SHORT: 短整型,取值范围[-32768, 32767]</li>\n<li>gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]</li>\n<li>gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]</li>\n<li>gl.FLOAT: 浮点型</li>\n</ul>\n<p><strong><em>normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间</em></strong></p>\n<p><strong><em>stride: 指定相邻2个顶点间的字节数，默认为0</em></strong></p>\n<p><strong><em>offset: 指定缓存区对象中的偏移量，设置为0即可</em></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如为2，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0,</span><br><span class=\"line\">    1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表2个顶点</span><br><span class=\"line\">如为4，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0, 1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表1个顶点</span><br></pre></td></tr></table></figure></p>\n<p>现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用<strong><em>enableVertexAttribArray</em></strong>来启用对应变量。</p>\n<h3 id=\"gl-enableVertexAttribArray-name\"><a href=\"#gl-enableVertexAttribArray-name\" class=\"headerlink\" title=\"gl.enableVertexAttribArray(name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a></h3><p><strong><em>name: 待启动的变量指针，也就是名称</em></strong></p>\n<p>所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点</p>\n<h3 id=\"gl-drawArrays-mode-first-count\"><a href=\"#gl-drawArrays-mode-first-count\" class=\"headerlink\" title=\"gl.drawArrays(mode, first, count)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a></h3><p><strong><em>mode: 需要绘制的图像形状</em></strong></p>\n<ul>\n<li>gl.POINTS: 绘制一个点。</li>\n<li>gl.LINE_STRIP: 绘制一条直线到下一个顶点。</li>\n<li>gl.LINE_LOOP: 绘制一条首尾相连的线。</li>\n<li>gl.LINES: 绘制一条线。</li>\n<li>gl.TRIANGLES: 绘制一个三角形。</li>\n</ul>\n<p><strong><em>first: 绘制的开始点</em></strong></p>\n<p><strong><em>count: 需要绘制的图形个数</em></strong></p>\n<p>看看屏幕吧，是不是出来了好多点。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面介绍了如何绘制单个点，本章主要介绍如何绘制多个点，绘制多个点依旧以绘制二维图像为例来讲解，因为绘制二维通向与绘制三维图像一样。</p>\n<p>之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：<strong><em>缓存区对象（buffer data）</em></strong>,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。</p>\n<h2 id=\"使用缓存区步骤\"><a href=\"#使用缓存区步骤\" class=\"headerlink\" title=\"使用缓存区步骤\"></a>使用缓存区步骤</h2><ul>\n<li>创建缓存区对象(gl.createBuffer())</li>\n<li>绑定缓存区对象(gl.bindBuffer())</li>\n<li>将数据写入缓存区对象(gl.bufferData())</li>\n<li>将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())</li>\n<li>开启attribute变量(gl.enableVertexAttribArray())</li>\n</ul>\n<h2 id=\"具体创建过程\"><a href=\"#具体创建过程\" class=\"headerlink\" title=\"具体创建过程\"></a>具体创建过程</h2><p>首先，我们仍然需要创建WebGL对象、片元着色器以及顶点着色器，具体创建的步骤以及原理，可参考之前的教程。具体代码实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 书写着色器代码 --&gt;</span><br><span class=\"line\">var v_Shader = `</span><br><span class=\"line\">    attribute vec4 a_p;</span><br><span class=\"line\">    void main() &#123;</span><br><span class=\"line\">        gl_Position = a_p;</span><br><span class=\"line\">        gl_PointSize = 10.0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">`;</span><br><span class=\"line\">var f_Shader = `</span><br><span class=\"line\">    void main()&#123;</span><br><span class=\"line\">        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">`;</span><br><span class=\"line\">&lt;!-- 创建WebGL --&gt;</span><br><span class=\"line\">var canvas = document.getElementById(id);</span><br><span class=\"line\">gl = canvas.getContext(&apos;webgl&apos;) || canvas.getContext(&apos;experimental-webgl&apos;);</span><br><span class=\"line\">&lt;!-- 创建片元操作程序 --&gt;</span><br><span class=\"line\">var program = gl.createProgram();</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 创建片元着色器 --&gt;</span><br><span class=\"line\">var fsShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class=\"line\">&lt;!-- 着色器对象绑定着色器代码 --&gt;</span><br><span class=\"line\">gl.shaderSource(fsShader, f_Shader);</span><br><span class=\"line\">&lt;!-- GLSE语法编译成js语法 --&gt;</span><br><span class=\"line\">gl.compileShader(fsShader);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 创建顶点着色器 --&gt;</span><br><span class=\"line\">var vsShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">&lt;!-- 着色器对象绑定着色器代码 --&gt;</span><br><span class=\"line\">gl.shaderSource(vsShader, v_Shader);</span><br><span class=\"line\">&lt;!-- GLSE语法编译成js语法 --&gt;</span><br><span class=\"line\">gl.compileShader(vsShader);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 运行程序绑定着色器--&gt;</span><br><span class=\"line\">gl.attachShader(program, vsShader);</span><br><span class=\"line\">gl.attachShader(program, fsShader);</span><br><span class=\"line\">&lt;!-- WebGL与program建立连接 --&gt;</span><br><span class=\"line\">gl.linkProgram(program);</span><br><span class=\"line\">&lt;!-- 使用此program --&gt;</span><br><span class=\"line\">gl.useProgram(program);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 初始化WebGL已经完成 --&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当创建好WebGL之后，可以通过着色器中的attrbute或者uniform对象来传递需要动态修改或设置的的变量。</p>\n<p>接下来我们需要进行缓冲区的操作：<br>首先，需要创建一个缓冲区来承载大量顶点的坐标<br>（代码继续上文）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 创建缓存区 --&gt;</span><br><span class=\"line\">var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">if(!vertexBuffer) &#123;</span><br><span class=\"line\">    log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!-- 将创建的缓存区对象绑定到target表示的目标上 --&gt;</span><br><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">&lt;!-- 开辟存储空间，向绑定在target上的缓存区对象中写入数据 --&gt;</span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">&lt;!-- 获取着色器中的变量值 --&gt;</span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">&lt;!-- 将缓存区对象绑定到着色器变量中 --&gt;</span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">&lt;!-- 启用缓存区 --&gt;</span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">&lt;!-- 绘制缓存区中画的多个顶点 --&gt;</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , array);</span><br></pre></td></tr></table></figure></p>\n<p>看完了绘制过程，让我们来拆解一下具体内容：</p>\n<p>首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，<strong><em>bingBuffer</em></strong>就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。</p>\n<h3 id=\"gl-bindBuffer-target-buffer\"><a href=\"#gl-bindBuffer-target-buffer\" class=\"headerlink\" title=\"gl.bindBuffer(target, buffer)\"></a><a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a></h3><p><strong><em>target: 指定存储缓存区的目标类型</em></strong></p>\n<ul>\n<li>gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据</li>\n<li>gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值</li>\n</ul>\n<p><strong><em>buffer: 自己创建的缓存区对象</em></strong></p>\n<p>接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用<strong><em>Float32Array</em></strong>类型来创建支持GLSL的数据。使用<strong><em>bufferData</em></strong>函数将数据放入缓存区内。</p>\n<h3 id=\"gl-bufferData-target-size-usage\"><a href=\"#gl-bufferData-target-size-usage\" class=\"headerlink\" title=\"gl.bufferData(target, size, usage)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a></h3><p><strong><em>target: 同上</em></strong></p>\n<p><strong><em>size: 为多个顶点坐标的集合数组</em></strong></p>\n<p><strong><em>usage: 表示程序将如何使用缓存区中的数据</em></strong></p>\n<ul>\n<li>gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次</li>\n<li>gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次</li>\n<li>gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次</li>\n</ul>\n<p>缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中<strong><em>getAttribLocation</em></strong>函数获取着色器中的attribute类型变量，并且通过<strong><em>vertexAttribPointer</em></strong>将其赋值改变，从而达到改变图像呈现。</p>\n<h3 id=\"gl-getAttribLocation-program-name\"><a href=\"#gl-getAttribLocation-program-name\" class=\"headerlink\" title=\"gl.getAttribLocation(program,name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a></h3><p><strong><em>param: webgl之前创建的进程</em></strong></p>\n<p><strong><em>name: 变量名称</em></strong></p>\n<h3 id=\"gl-vertexAttribPointer-name-size-type-normalized-stride-offset\"><a href=\"#gl-vertexAttribPointer-name-size-type-normalized-stride-offset\" class=\"headerlink\" title=\"gl.vertexAttribPointer(name, size, type, normalized, stride, offset)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a></h3><p><strong><em>name: 指定要赋值的attribute变量位置</em></strong></p>\n<p><strong><em>size: 指定每个顶点数据的分量个数（1或4）</em></strong></p>\n<p><strong><em>type: 指定传入的数据格式</em></strong></p>\n<ul>\n<li>gl.BYTE: 字节型, 取值范围[-128, 127]</li>\n<li>gl.SHORT: 短整型,取值范围[-32768, 32767]</li>\n<li>gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]</li>\n<li>gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]</li>\n<li>gl.FLOAT: 浮点型</li>\n</ul>\n<p><strong><em>normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间</em></strong></p>\n<p><strong><em>stride: 指定相邻2个顶点间的字节数，默认为0</em></strong></p>\n<p><strong><em>offset: 指定缓存区对象中的偏移量，设置为0即可</em></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如为2，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0,</span><br><span class=\"line\">    1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表2个顶点</span><br><span class=\"line\">如为4，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0, 1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表1个顶点</span><br></pre></td></tr></table></figure></p>\n<p>现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用<strong><em>enableVertexAttribArray</em></strong>来启用对应变量。</p>\n<h3 id=\"gl-enableVertexAttribArray-name\"><a href=\"#gl-enableVertexAttribArray-name\" class=\"headerlink\" title=\"gl.enableVertexAttribArray(name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a></h3><p><strong><em>name: 待启动的变量指针，也就是名称</em></strong></p>\n<p>所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点</p>\n<h3 id=\"gl-drawArrays-mode-first-count\"><a href=\"#gl-drawArrays-mode-first-count\" class=\"headerlink\" title=\"gl.drawArrays(mode, first, count)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a></h3><p><strong><em>mode: 需要绘制的图像形状</em></strong></p>\n<ul>\n<li>gl.POINTS: 绘制一个点。</li>\n<li>gl.LINE_STRIP: 绘制一条直线到下一个顶点。</li>\n<li>gl.LINE_LOOP: 绘制一条首尾相连的线。</li>\n<li>gl.LINES: 绘制一条线。</li>\n<li>gl.TRIANGLES: 绘制一个三角形。</li>\n</ul>\n<p><strong><em>first: 绘制的开始点</em></strong></p>\n<p><strong><em>count: 需要绘制的图形个数</em></strong></p>\n<p>看看屏幕吧，是不是出来了好多点。</p>\n"},{"title":"WebGL是什么","date":"2018-06-17T04:29:44.043Z","author":"leo","thumbnail":null,"blogexcerpt":"改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。","_content":"\n> 改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。\n\n网站的未来是这样子的：\n\n![3D网站效果](/assets/img/yanglei10-2.gif)\n\n的确，3D技术会让平淡的网页变的更酷，更让人眼花撩眼，这本后隐藏着什么呢？来来，咱们做下来泡一壶茶，边喝边聊，这个神奇的家伙叫做***WebGL***。\n\n谈起WebGL可能有一些人比较陌生，实际上WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。\n> 此链接可以查看你的游览器是否支持WebGL以及支持的版本。\n> [检测浏览器是否支持WebGL](http://webglreport.com)\n\n看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助GLSL ES语法来操作的.\n\n基于WebGL周边也衍生了众多的第三方库，如开发应用类的Three.js，开发游戏类的Egert.js等，都大大的降低了学习WebGL的成本，但是本着有问题解决问题，没问题制造问题在解决问题的程序猿态度，还是觉得应该稍微了解一下WebGL一些基本的概念，以便能更好的去理解不同框架带来的便捷以及优势。\n\n接下来先简单介绍一下使用到的知识要点。\n\n### 创建webGL对象\n不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理\n```\nvar canvas = document.getElementById(\"glcanvas\");\ngl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n```\n\n### 着色器\nWebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。\n\n\nWebGL需要两种着色器\n\n- 顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。**顶点(Vertex)**是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。\n- 片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。**片元(fragment)**是一个WebGL的术语，你可以将其理解成像素。\n\n > **着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译**\n\n 创建顶点着色器：\n```\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n创建片元着色器：\n```\n var FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n浏览器的整个过程如下：\n\n![webgl渲染过程](/assets/img/yanglei5.jpg)\n\n着色器中包含几个内置变量：**gl_Position, gl_PointSize, gl_FragColor**。\n>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，**正确应为：(1.0,1.0,1.0,1.0)**\n- **gl_Position**: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为**齐次坐标**，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。\n- **gl_PointSize**：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。\n- **gl_FragColor**：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从**0.0-1.0**对应Javascript中的**#00-#FF**。\n有了着色器我们就可以着手去绘制图像了，既然绘制3D图形，必然会有对应的三维坐标系，WebGL采用右手坐标系，如图所示：\n\n![webgl渲染过程](/assets/img/right.jpg)\n\n### 使用着色器\n#### 让我们来看看如何把着色器代码编译并且使用起来\n着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。\n```\nvar program = gl.createProgram();\n// 创建顶点着色器 \nvar vShader = gl.createShader(gl.VERTEX_SHADER);\n// 创建片元着色器 \nvar fShader = gl.createShader(gl.FRAGMENT_SHADER);\n// shader容器与着色器绑定 \ngl.shaderSource(vShader, VSHADER_SOURCE);\ngl.shaderSource(fShader, FSHADER_SOURCE);\n// 将GLSE语言编译成浏览器可用代码 \ngl.compileShader(vShader);\ngl.compileShader(fShader);\n// 将着色器添加到程序上 \ngl.attachShader(program, vShader);\ngl.attachShader(program, fShader);\n// 链接程序，在链接操作执行以后，可以任意修改shader的源代码，\n对shader重新编译不会影响整个程序，除非重新链接程序 \ngl.linkProgram(program);\n// 加载并使用链接好的程序 \ngl.useProgram(program);\n```\n\n#### 让我们尝试绘制一个点\n```\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\ngl.drawArrays(gl.POINTS, 0 ,1);\n```\n\n我们来看一看最终结果,果然出来了一个点\n\n![我是图片的Alt](/assets/img/yanglei8-2.jpg),\n\nWhy? 咋这么模糊？没错不是你的眼镜度数又高了，的确是模糊的。\n\n让我们来说说WebGL的坐标系\n\n因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei12-1.jpg)\n\n图上的实例是在使用源生WebGL时，并且未对视角有设置的情况下的默认值。默认视角的位置为(0.0, 0.0, 0.0)，并且lookAt(0.0, 0.0, -1.0)，也就是默认的视角是看向z轴负坐标的，如果点在z的正位置上，则是无法看到点的。\n\n绘制之后，发现这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：\n\n```\n//错误\n<canvas id=\"glcanvas\" style=\"width: 700px; height: 500px;\">\n//正确的方式\n<canvas id=\"glcanvas\" width=\"700\" height=\"500\">\n```\n\n一个真实尺寸的清晰的点就出现了\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei6.jpg)\n\n但我们辛苦绘制出来的点居然是正方形的，但WebGL是未提供绘制圆点的方法。\n\n我们首先来了解一下WebGL的渲染机制，顶点着色器的信息在传递给OpenGL底层绘制的时候，会先进行光栅化，也就是把点转化成对应的像素。然后在片元着色器会逐个点进行渲染，最终就达到了视觉看到的效果。\n\n![光栅化](/assets/img/yanglei10-3.jpg)\n\n点也是一样，会将点转变成多个像素点，所以要变成圆点，需要如下的方式：\n![光栅化](/assets/img/10-2.jpg)\n我们需要在片元着色器中来处理，将非原型区域的像素点，不用片元着色器来绘制，着色器需要判断距离圆点的位置超过0.5的话，就忽略此片元点，最终就会出现一个圆点的效果。\n\n```\nvar FSHADER_SOURCE = `\n #ifdef GL_ES\n     precision mediump float;\n #endif\nvoid main() {\n  float d = distance(gl_PointCoord, vec2(0.5,0.5));\n    if(d < 0.5){\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }else{ discard;} \n}`;\n```\n\n如下图，我们绘制了一个圆点：\n![圆点](/assets/img/yanglei10-4.png)\n\n本章我们已经了解了WebGL的一些背景，以及如何使用一些基本功能，那么如何把着色器动态化并且同时高性能的绘制大量点呢？下一章我们会解开WebGL缓存区的面纱。\n\n#### 扩展阅读\n[1] http://webglreport.com","source":"_posts/2018-04-04-yanglei10.md","raw":"---\ntitle: WebGL是什么\ndate: {{ date }}\nauthor: leo\ntags: WebGL\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。\n---\n\n> 改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。\n\n网站的未来是这样子的：\n\n![3D网站效果](/assets/img/yanglei10-2.gif)\n\n的确，3D技术会让平淡的网页变的更酷，更让人眼花撩眼，这本后隐藏着什么呢？来来，咱们做下来泡一壶茶，边喝边聊，这个神奇的家伙叫做***WebGL***。\n\n谈起WebGL可能有一些人比较陌生，实际上WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。\n> 此链接可以查看你的游览器是否支持WebGL以及支持的版本。\n> [检测浏览器是否支持WebGL](http://webglreport.com)\n\n看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助GLSL ES语法来操作的.\n\n基于WebGL周边也衍生了众多的第三方库，如开发应用类的Three.js，开发游戏类的Egert.js等，都大大的降低了学习WebGL的成本，但是本着有问题解决问题，没问题制造问题在解决问题的程序猿态度，还是觉得应该稍微了解一下WebGL一些基本的概念，以便能更好的去理解不同框架带来的便捷以及优势。\n\n接下来先简单介绍一下使用到的知识要点。\n\n### 创建webGL对象\n不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理\n```\nvar canvas = document.getElementById(\"glcanvas\");\ngl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n```\n\n### 着色器\nWebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。\n\n\nWebGL需要两种着色器\n\n- 顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。**顶点(Vertex)**是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。\n- 片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。**片元(fragment)**是一个WebGL的术语，你可以将其理解成像素。\n\n > **着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译**\n\n 创建顶点着色器：\n```\nvar VSHADER_SOURCE = \n  'void main() {\\n' +\n    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n创建片元着色器：\n```\n var FSHADER_SOURCE =\n    'void main() {\\n' +\n    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' +\n'}\\n';\n```\n\n浏览器的整个过程如下：\n\n![webgl渲染过程](/assets/img/yanglei5.jpg)\n\n着色器中包含几个内置变量：**gl_Position, gl_PointSize, gl_FragColor**。\n>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，**正确应为：(1.0,1.0,1.0,1.0)**\n- **gl_Position**: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为**齐次坐标**，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。\n- **gl_PointSize**：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。\n- **gl_FragColor**：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从**0.0-1.0**对应Javascript中的**#00-#FF**。\n有了着色器我们就可以着手去绘制图像了，既然绘制3D图形，必然会有对应的三维坐标系，WebGL采用右手坐标系，如图所示：\n\n![webgl渲染过程](/assets/img/right.jpg)\n\n### 使用着色器\n#### 让我们来看看如何把着色器代码编译并且使用起来\n着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。\n```\nvar program = gl.createProgram();\n// 创建顶点着色器 \nvar vShader = gl.createShader(gl.VERTEX_SHADER);\n// 创建片元着色器 \nvar fShader = gl.createShader(gl.FRAGMENT_SHADER);\n// shader容器与着色器绑定 \ngl.shaderSource(vShader, VSHADER_SOURCE);\ngl.shaderSource(fShader, FSHADER_SOURCE);\n// 将GLSE语言编译成浏览器可用代码 \ngl.compileShader(vShader);\ngl.compileShader(fShader);\n// 将着色器添加到程序上 \ngl.attachShader(program, vShader);\ngl.attachShader(program, fShader);\n// 链接程序，在链接操作执行以后，可以任意修改shader的源代码，\n对shader重新编译不会影响整个程序，除非重新链接程序 \ngl.linkProgram(program);\n// 加载并使用链接好的程序 \ngl.useProgram(program);\n```\n\n#### 让我们尝试绘制一个点\n```\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\ngl.drawArrays(gl.POINTS, 0 ,1);\n```\n\n我们来看一看最终结果,果然出来了一个点\n\n![我是图片的Alt](/assets/img/yanglei8-2.jpg),\n\nWhy? 咋这么模糊？没错不是你的眼镜度数又高了，的确是模糊的。\n\n让我们来说说WebGL的坐标系\n\n因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei12-1.jpg)\n\n图上的实例是在使用源生WebGL时，并且未对视角有设置的情况下的默认值。默认视角的位置为(0.0, 0.0, 0.0)，并且lookAt(0.0, 0.0, -1.0)，也就是默认的视角是看向z轴负坐标的，如果点在z的正位置上，则是无法看到点的。\n\n绘制之后，发现这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：\n\n```\n//错误\n<canvas id=\"glcanvas\" style=\"width: 700px; height: 500px;\">\n//正确的方式\n<canvas id=\"glcanvas\" width=\"700\" height=\"500\">\n```\n\n一个真实尺寸的清晰的点就出现了\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei6.jpg)\n\n但我们辛苦绘制出来的点居然是正方形的，但WebGL是未提供绘制圆点的方法。\n\n我们首先来了解一下WebGL的渲染机制，顶点着色器的信息在传递给OpenGL底层绘制的时候，会先进行光栅化，也就是把点转化成对应的像素。然后在片元着色器会逐个点进行渲染，最终就达到了视觉看到的效果。\n\n![光栅化](/assets/img/yanglei10-3.jpg)\n\n点也是一样，会将点转变成多个像素点，所以要变成圆点，需要如下的方式：\n![光栅化](/assets/img/10-2.jpg)\n我们需要在片元着色器中来处理，将非原型区域的像素点，不用片元着色器来绘制，着色器需要判断距离圆点的位置超过0.5的话，就忽略此片元点，最终就会出现一个圆点的效果。\n\n```\nvar FSHADER_SOURCE = `\n #ifdef GL_ES\n     precision mediump float;\n #endif\nvoid main() {\n  float d = distance(gl_PointCoord, vec2(0.5,0.5));\n    if(d < 0.5){\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }else{ discard;} \n}`;\n```\n\n如下图，我们绘制了一个圆点：\n![圆点](/assets/img/yanglei10-4.png)\n\n本章我们已经了解了WebGL的一些背景，以及如何使用一些基本功能，那么如何把着色器动态化并且同时高性能的绘制大量点呢？下一章我们会解开WebGL缓存区的面纱。\n\n#### 扩展阅读\n[1] http://webglreport.com","slug":"2018-04-04-yanglei10","published":1,"updated":"2018-06-17T07:41:13.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo5f000oo89kwdils2fj","content":"<blockquote>\n<p>改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。</p>\n</blockquote>\n<p>网站的未来是这样子的：</p>\n<p><img src=\"/assets/img/yanglei10-2.gif\" alt=\"3D网站效果\"></p>\n<p>的确，3D技术会让平淡的网页变的更酷，更让人眼花撩眼，这本后隐藏着什么呢？来来，咱们做下来泡一壶茶，边喝边聊，这个神奇的家伙叫做<strong><em>WebGL</em></strong>。</p>\n<p>谈起WebGL可能有一些人比较陌生，实际上WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。</p>\n<blockquote>\n<p>此链接可以查看你的游览器是否支持WebGL以及支持的版本。<br><a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">检测浏览器是否支持WebGL</a></p>\n</blockquote>\n<p>看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助GLSL ES语法来操作的.</p>\n<p>基于WebGL周边也衍生了众多的第三方库，如开发应用类的Three.js，开发游戏类的Egert.js等，都大大的降低了学习WebGL的成本，但是本着有问题解决问题，没问题制造问题在解决问题的程序猿态度，还是觉得应该稍微了解一下WebGL一些基本的概念，以便能更好的去理解不同框架带来的便捷以及优势。</p>\n<p>接下来先简单介绍一下使用到的知识要点。</p>\n<h3 id=\"创建webGL对象\"><a href=\"#创建webGL对象\" class=\"headerlink\" title=\"创建webGL对象\"></a>创建webGL对象</h3><p>不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><p>WebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。</p>\n<p>WebGL需要两种着色器</p>\n<ul>\n<li>顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点(Vertex)</strong>是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。</li>\n<li><p>片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。<strong>片元(fragment)</strong>是一个WebGL的术语，你可以将其理解成像素。</p>\n<blockquote>\n<p><strong>着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译</strong></p>\n</blockquote>\n<p>创建顶点着色器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>创建片元着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器的整个过程如下：</p>\n<p><img src=\"/assets/img/yanglei5.jpg\" alt=\"webgl渲染过程\"></p>\n<p>着色器中包含几个内置变量：<strong>gl_Position, gl_PointSize, gl_FragColor</strong>。</p>\n<blockquote>\n<p>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，<strong>正确应为：(1.0,1.0,1.0,1.0)</strong></p>\n<ul>\n<li><strong>gl_Position</strong>: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为<strong>齐次坐标</strong>，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。</li>\n<li><strong>gl_PointSize</strong>：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。</li>\n<li><strong>gl_FragColor</strong>：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从<strong>0.0-1.0</strong>对应Javascript中的<strong>#00-#FF</strong>。<br>有了着色器我们就可以着手去绘制图像了，既然绘制3D图形，必然会有对应的三维坐标系，WebGL采用右手坐标系，如图所示：</li>\n</ul>\n</blockquote>\n<p><img src=\"/assets/img/right.jpg\" alt=\"webgl渲染过程\"></p>\n<h3 id=\"使用着色器\"><a href=\"#使用着色器\" class=\"headerlink\" title=\"使用着色器\"></a>使用着色器</h3><h4 id=\"让我们来看看如何把着色器代码编译并且使用起来\"><a href=\"#让我们来看看如何把着色器代码编译并且使用起来\" class=\"headerlink\" title=\"让我们来看看如何把着色器代码编译并且使用起来\"></a>让我们来看看如何把着色器代码编译并且使用起来</h4><p>着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var program = gl.createProgram();</span><br><span class=\"line\">// 创建顶点着色器 </span><br><span class=\"line\">var vShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">// 创建片元着色器 </span><br><span class=\"line\">var fShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class=\"line\">// shader容器与着色器绑定 </span><br><span class=\"line\">gl.shaderSource(vShader, VSHADER_SOURCE);</span><br><span class=\"line\">gl.shaderSource(fShader, FSHADER_SOURCE);</span><br><span class=\"line\">// 将GLSE语言编译成浏览器可用代码 </span><br><span class=\"line\">gl.compileShader(vShader);</span><br><span class=\"line\">gl.compileShader(fShader);</span><br><span class=\"line\">// 将着色器添加到程序上 </span><br><span class=\"line\">gl.attachShader(program, vShader);</span><br><span class=\"line\">gl.attachShader(program, fShader);</span><br><span class=\"line\">// 链接程序，在链接操作执行以后，可以任意修改shader的源代码，</span><br><span class=\"line\">对shader重新编译不会影响整个程序，除非重新链接程序 </span><br><span class=\"line\">gl.linkProgram(program);</span><br><span class=\"line\">// 加载并使用链接好的程序 </span><br><span class=\"line\">gl.useProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"让我们尝试绘制一个点\"><a href=\"#让我们尝试绘制一个点\" class=\"headerlink\" title=\"让我们尝试绘制一个点\"></a>让我们尝试绘制一个点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 ,1);</span><br></pre></td></tr></table></figure>\n<p>我们来看一看最终结果,果然出来了一个点</p>\n<p><img src=\"/assets/img/yanglei8-2.jpg\" alt=\"我是图片的Alt\">,</p>\n<p>Why? 咋这么模糊？没错不是你的眼镜度数又高了，的确是模糊的。</p>\n<p>让我们来说说WebGL的坐标系</p>\n<p>因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：</p>\n<p><img src=\"/assets/img/yanglei12-1.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>图上的实例是在使用源生WebGL时，并且未对视角有设置的情况下的默认值。默认视角的位置为(0.0, 0.0, 0.0)，并且lookAt(0.0, 0.0, -1.0)，也就是默认的视角是看向z轴负坐标的，如果点在z的正位置上，则是无法看到点的。</p>\n<p>绘制之后，发现这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//错误</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; style=&quot;width: 700px; height: 500px;&quot;&gt;</span><br><span class=\"line\">//正确的方式</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>一个真实尺寸的清晰的点就出现了</p>\n<p><img src=\"/assets/img/yanglei6.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>但我们辛苦绘制出来的点居然是正方形的，但WebGL是未提供绘制圆点的方法。</p>\n<p>我们首先来了解一下WebGL的渲染机制，顶点着色器的信息在传递给OpenGL底层绘制的时候，会先进行光栅化，也就是把点转化成对应的像素。然后在片元着色器会逐个点进行渲染，最终就达到了视觉看到的效果。</p>\n<p><img src=\"/assets/img/yanglei10-3.jpg\" alt=\"光栅化\"></p>\n<p>点也是一样，会将点转变成多个像素点，所以要变成圆点，需要如下的方式：<br><img src=\"/assets/img/10-2.jpg\" alt=\"光栅化\"><br>我们需要在片元着色器中来处理，将非原型区域的像素点，不用片元着色器来绘制，着色器需要判断距离圆点的位置超过0.5的话，就忽略此片元点，最终就会出现一个圆点的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var FSHADER_SOURCE = `</span><br><span class=\"line\"> #ifdef GL_ES</span><br><span class=\"line\">     precision mediump float;</span><br><span class=\"line\"> #endif</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  float d = distance(gl_PointCoord, vec2(0.5,0.5));</span><br><span class=\"line\">    if(d &lt; 0.5)&#123;</span><br><span class=\"line\">      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">    &#125;else&#123; discard;&#125; </span><br><span class=\"line\">&#125;`;</span><br></pre></td></tr></table></figure>\n<p>如下图，我们绘制了一个圆点：<br><img src=\"/assets/img/yanglei10-4.png\" alt=\"圆点\"></p>\n<p>本章我们已经了解了WebGL的一些背景，以及如何使用一些基本功能，那么如何把着色器动态化并且同时高性能的绘制大量点呢？下一章我们会解开WebGL缓存区的面纱。</p>\n<h4 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h4><p>[1] <a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">http://webglreport.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>改革开发40年以来，世界日新月异，无论从生活到精神上都有了颠覆性的变化，曾经教授还是教书的，砖家还叫专家，太阳还不叫日，菊花还是一种花，老王还没那么多，Web还只需要做IE，XHR还没出生的时候，怎么能想到现在浏览器会提供如此丰富多彩的多媒体生活，无论是音频、视频、以及各种漂亮的页面都在让用户更好的拥抱着互联网，当二维页面无法满足用户之后，会出现什么样的内容来继续推进Web进展呢，没错，就是3D，浏览器中看到的内容从平面变成3D的时候，oH，My God，提起来都让人兴奋。</p>\n</blockquote>\n<p>网站的未来是这样子的：</p>\n<p><img src=\"/assets/img/yanglei10-2.gif\" alt=\"3D网站效果\"></p>\n<p>的确，3D技术会让平淡的网页变的更酷，更让人眼花撩眼，这本后隐藏着什么呢？来来，咱们做下来泡一壶茶，边喝边聊，这个神奇的家伙叫做<strong><em>WebGL</em></strong>。</p>\n<p>谈起WebGL可能有一些人比较陌生，实际上WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。</p>\n<blockquote>\n<p>此链接可以查看你的游览器是否支持WebGL以及支持的版本。<br><a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">检测浏览器是否支持WebGL</a></p>\n</blockquote>\n<p>看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助GLSL ES语法来操作的.</p>\n<p>基于WebGL周边也衍生了众多的第三方库，如开发应用类的Three.js，开发游戏类的Egert.js等，都大大的降低了学习WebGL的成本，但是本着有问题解决问题，没问题制造问题在解决问题的程序猿态度，还是觉得应该稍微了解一下WebGL一些基本的概念，以便能更好的去理解不同框架带来的便捷以及优势。</p>\n<p>接下来先简单介绍一下使用到的知识要点。</p>\n<h3 id=\"创建webGL对象\"><a href=\"#创建webGL对象\" class=\"headerlink\" title=\"创建webGL对象\"></a>创建webGL对象</h3><p>不同浏览器生命WebGL对象方式有所区别，虽然大部分浏览器都支持experimental-webgl，而且以后会变成webgl，所以创建时做一下兼容处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var canvas = document.getElementById(&quot;glcanvas&quot;);</span><br><span class=\"line\">gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><p>WebGL依赖一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL必须使用它。着色器不仅强大，而且更复杂，仅仅通过一条简单的绘图指令是不能操作它的。</p>\n<p>WebGL需要两种着色器</p>\n<ul>\n<li>顶点着色器（Vertex shader）：顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点(Vertex)</strong>是指二维或三维空间的一个点，比如二维或三维空间线与线之间的交叉点或者端点。</li>\n<li><p>片元着色器（Fragment shader）：进行逐片元处理过程（如光照等）的程序。<strong>片元(fragment)</strong>是一个WebGL的术语，你可以将其理解成像素。</p>\n<blockquote>\n<p><strong>着色器语言使用的是GLSL ES语言，所以在javascript需要将之存放在字符串中，等待调用编译</strong></p>\n</blockquote>\n<p>创建顶点着色器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>创建片元着色器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">    &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n&apos; +</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>浏览器的整个过程如下：</p>\n<p><img src=\"/assets/img/yanglei5.jpg\" alt=\"webgl渲染过程\"></p>\n<p>着色器中包含几个内置变量：<strong>gl_Position, gl_PointSize, gl_FragColor</strong>。</p>\n<blockquote>\n<p>着色器语言中涉及到vec4的数据类型，此数据类型是一个思维浮点数组，所以其值不可以是整形如(1,1,1,1)，<strong>正确应为：(1.0,1.0,1.0,1.0)</strong></p>\n<ul>\n<li><strong>gl_Position</strong>: 为一种vec4类型的变量，且必须被赋值。四维坐标矢量，我们称之为<strong>齐次坐标</strong>，即(x,y,z,w)等价于三维左边(x/w,y/w,z/w)，w相当于深度，没有特殊要求设置为1.0即可。</li>\n<li><strong>gl_PointSize</strong>：表示顶点的尺寸，也是浮点数，为非必填项，如果不填则默认显示为1.0。</li>\n<li><strong>gl_FragColor</strong>：该变量为片元着色器唯一的内置变量，表示其颜色，也是一个vec4类型变量，分别代表（R,G,B,A），不过颜色范围是从<strong>0.0-1.0</strong>对应Javascript中的<strong>#00-#FF</strong>。<br>有了着色器我们就可以着手去绘制图像了，既然绘制3D图形，必然会有对应的三维坐标系，WebGL采用右手坐标系，如图所示：</li>\n</ul>\n</blockquote>\n<p><img src=\"/assets/img/right.jpg\" alt=\"webgl渲染过程\"></p>\n<h3 id=\"使用着色器\"><a href=\"#使用着色器\" class=\"headerlink\" title=\"使用着色器\"></a>使用着色器</h3><h4 id=\"让我们来看看如何把着色器代码编译并且使用起来\"><a href=\"#让我们来看看如何把着色器代码编译并且使用起来\" class=\"headerlink\" title=\"让我们来看看如何把着色器代码编译并且使用起来\"></a>让我们来看看如何把着色器代码编译并且使用起来</h4><p>着色器代码需要载入到一个程序中，webgl使用此程序才能调用着色器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var program = gl.createProgram();</span><br><span class=\"line\">// 创建顶点着色器 </span><br><span class=\"line\">var vShader = gl.createShader(gl.VERTEX_SHADER);</span><br><span class=\"line\">// 创建片元着色器 </span><br><span class=\"line\">var fShader = gl.createShader(gl.FRAGMENT_SHADER);</span><br><span class=\"line\">// shader容器与着色器绑定 </span><br><span class=\"line\">gl.shaderSource(vShader, VSHADER_SOURCE);</span><br><span class=\"line\">gl.shaderSource(fShader, FSHADER_SOURCE);</span><br><span class=\"line\">// 将GLSE语言编译成浏览器可用代码 </span><br><span class=\"line\">gl.compileShader(vShader);</span><br><span class=\"line\">gl.compileShader(fShader);</span><br><span class=\"line\">// 将着色器添加到程序上 </span><br><span class=\"line\">gl.attachShader(program, vShader);</span><br><span class=\"line\">gl.attachShader(program, fShader);</span><br><span class=\"line\">// 链接程序，在链接操作执行以后，可以任意修改shader的源代码，</span><br><span class=\"line\">对shader重新编译不会影响整个程序，除非重新链接程序 </span><br><span class=\"line\">gl.linkProgram(program);</span><br><span class=\"line\">// 加载并使用链接好的程序 </span><br><span class=\"line\">gl.useProgram(program);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"让我们尝试绘制一个点\"><a href=\"#让我们尝试绘制一个点\" class=\"headerlink\" title=\"让我们尝试绘制一个点\"></a>让我们尝试绘制一个点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 ,1);</span><br></pre></td></tr></table></figure>\n<p>我们来看一看最终结果,果然出来了一个点</p>\n<p><img src=\"/assets/img/yanglei8-2.jpg\" alt=\"我是图片的Alt\">,</p>\n<p>Why? 咋这么模糊？没错不是你的眼镜度数又高了，的确是模糊的。</p>\n<p>让我们来说说WebGL的坐标系</p>\n<p>因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：</p>\n<p><img src=\"/assets/img/yanglei12-1.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>图上的实例是在使用源生WebGL时，并且未对视角有设置的情况下的默认值。默认视角的位置为(0.0, 0.0, 0.0)，并且lookAt(0.0, 0.0, -1.0)，也就是默认的视角是看向z轴负坐标的，如果点在z的正位置上，则是无法看到点的。</p>\n<p>绘制之后，发现这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//错误</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; style=&quot;width: 700px; height: 500px;&quot;&gt;</span><br><span class=\"line\">//正确的方式</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>一个真实尺寸的清晰的点就出现了</p>\n<p><img src=\"/assets/img/yanglei6.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>但我们辛苦绘制出来的点居然是正方形的，但WebGL是未提供绘制圆点的方法。</p>\n<p>我们首先来了解一下WebGL的渲染机制，顶点着色器的信息在传递给OpenGL底层绘制的时候，会先进行光栅化，也就是把点转化成对应的像素。然后在片元着色器会逐个点进行渲染，最终就达到了视觉看到的效果。</p>\n<p><img src=\"/assets/img/yanglei10-3.jpg\" alt=\"光栅化\"></p>\n<p>点也是一样，会将点转变成多个像素点，所以要变成圆点，需要如下的方式：<br><img src=\"/assets/img/10-2.jpg\" alt=\"光栅化\"><br>我们需要在片元着色器中来处理，将非原型区域的像素点，不用片元着色器来绘制，着色器需要判断距离圆点的位置超过0.5的话，就忽略此片元点，最终就会出现一个圆点的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var FSHADER_SOURCE = `</span><br><span class=\"line\"> #ifdef GL_ES</span><br><span class=\"line\">     precision mediump float;</span><br><span class=\"line\"> #endif</span><br><span class=\"line\">void main() &#123;</span><br><span class=\"line\">  float d = distance(gl_PointCoord, vec2(0.5,0.5));</span><br><span class=\"line\">    if(d &lt; 0.5)&#123;</span><br><span class=\"line\">      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">    &#125;else&#123; discard;&#125; </span><br><span class=\"line\">&#125;`;</span><br></pre></td></tr></table></figure>\n<p>如下图，我们绘制了一个圆点：<br><img src=\"/assets/img/yanglei10-4.png\" alt=\"圆点\"></p>\n<p>本章我们已经了解了WebGL的一些背景，以及如何使用一些基本功能，那么如何把着色器动态化并且同时高性能的绘制大量点呢？下一章我们会解开WebGL缓存区的面纱。</p>\n<h4 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h4><p>[1] <a href=\"http://webglreport.com\" target=\"_blank\" rel=\"noopener\">http://webglreport.com</a></p>\n"},{"title":"WebGL进阶","date":"2018-06-17T04:29:44.044Z","author":"leo","thumbnail":null,"blogexcerpt":"程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。","_content":"\n程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。（如不知道怎么创建WebGL，可参考上篇文章，点击走起）\n\n首先让我来介绍2个变量，我们需要借助这2个变量搭建的桥梁才能使JavaScript与GLSL ES之间进行沟通。\n\n- attribute： 用于顶点点着色器（**Vertex Shader**）传值时使用。\n- uniform：可用于顶点着色器（**Vertex Shader**）与片元着色器（**Fragment Shader**）使用。\n\n#### 将顶点动态化\n先在顶点着色器代码中，将对应的vec4的固定值变成变量\n```\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n位置参数使用了**attribute**变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。\n\n使用WebGL来获取对应参数的存储地址地址\n```\n//返回对应的地址信息\nvar aPosition = gl.getAttribLocation(gl.program, 'a_Position');\n//判断地址是否获取成功\nif(aPosition < 0) {\n    console.log('没有获取到对应position');\n}\n```\n\n然后给变量赋值\n```\ngl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);\n//或者使用Float32Array来传参\nvar p = new Float32Array([1.0, 1.0, 1.0]);\ngl.vertexAttrib3fv(aPosition, p);\n```\n\n    注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\n    vertexAttrib函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    v：表示传如的为一个vector变量。\n\n也就是说对应设置顶点着色器的函数有一下几种功能，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a>**：\n\n- void gl.vertexAttrib1f(index, v0);\n- void gl.vertexAttrib2f(index, v0, v1);\n- void gl.vertexAttrib3f(index, v0, v1, v2);\n- void gl.vertexAttrib4f(index, v0, v1, v2, v3);\n\n- void gl.vertexAttrib1fv(index, value);\n- void gl.vertexAttrib2fv(index, value);\n- void gl.vertexAttrib3fv(index, value);\n- void gl.vertexAttrib4fv(index, value);\n\n同样操作可以如下修改PointSize：\n```\n//着色器中添加变量\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'attribute float a_PointSize;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = a_PointSize;\\n' + \n  '}\\n';\nvar aPointSize = gl.getAttribLocation(gl.program, 'a_PointSize');\ngl.vertexAttrib1f(aPointSize, 10.0);\n```\n\n#### 片元着色器编程\n对片元着色器变成需要使用uniform变量来承载。\n```\n var FSHADER_SOURCE =\n'precision mediump float;\\n'+\n'uniform vec4 vColor;\\n'+\n'void main() {\\n' +\n'  gl_FragColor = vColor;\\n' + // Set the point color\n'}\\n';\n```\n获取片元着色器变量地址\n```\nvar vColor = gl.getUniformLocation(gl.program, 'vColor');\n```\n给变量赋值\n```\ngl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);\n//或使用Float32Array来传参\nvar color = new Float32Array([1.0, 0.0, 0.0, 1.0]);\ngl.uniform4fv(vColor,color)\n```\n\n    注意：uniform3fv这个函数是典型的GLSL语法命名规范，\n    uniform3fv函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    u：表示参数是Uint32Array类型，\n    i：表示参数是integer类型，\n    ui：表示参数是unsigned integer类型，\n    v：表示传如的为一个vector变量。\n\nuniform对应函数同attribute的函数构成相似，这里就不详细列举，具体请参考 [1]，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a>**\n\n>着色器中的代码**precision mediump float;**表示的意思是着色器中配置的float对象会占用中等尺寸内存。\n具体包含的尺寸：\n- highp for vertex positions,\n- mediump for texture coordinates,\n- lowp for colors.\n\n如果不设置此参数会报错：\n\n![我是图片的Alt](/assets/img/yanglei8.jpg)\n\n\n我们可以绘制自定义的点了，接下来我们就可以尝试绘制大批量点来达到波浪的基础效果，但是之前的操作都是针对一个点的，如何可以同时绘制多个订点呢，如果你的回答是循环数据，BINGGO，没错这样你的确是可以达到这个目的，但是不是我们接下来要讲的，因为在3D绘制的时候是会经常出现大批量点、线、面的绘制的，所以WebGL提供了一种承载机制来达到传递多点的能力，说了这么多，也让我们来看看它到底是什么吧\n\n### 缓存区对象\n之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：***缓存区对象（buffer data）***,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。\n\n#### 使用缓存区步骤\n- 创建缓存区对象(gl.createBuffer())\n- 绑定缓存区对象(gl.bindBuffer())\n- 将数据写入缓存区对象(gl.bufferData())\n- 将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())\n- 开启attribute变量(gl.enableVertexAttribArray())\n\n我们需要进行缓冲区的操作：\n首先，需要创建一个缓冲区来承载大量顶点的坐标\n（代码继续上文）\n```\n// 创建缓存区 \nvar vertexBuffer = gl.createBuffer();\nif(!vertexBuffer) {\n    log('创建缓存区失败。');\n    return -1;\n}\n// 将创建的缓存区对象绑定到target表示的目标上 \ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n// 开辟存储空间，向绑定在target上的缓存区对象中写入数据 \ngl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n// 获取着色器中的变量值 \nvar a_position = gl.getAttribLocation(gl.program, 'a_p');\n// 将缓存区对象绑定到着色器变量中 \ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n// 启用缓存区 \ngl.enableVertexAttribArray(a_position);\n// 绘制缓存区中画的多个顶点 \ngl.drawArrays(gl.POINTS, 0 , array);\n```\n\n看完了绘制过程，让我们来拆解一下具体内容：\n\n首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，***bingBuffer***就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。\n#### <a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a>\n\n***target: 指定存储缓存区的目标类型***\n- gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据\n- gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值\n\n***buffer: 自己创建的缓存区对象***\n\n接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用***Float32Array***类型来创建支持GLSL的数据。使用***bufferData***函数将数据放入缓存区内。\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a>\n\n***target: 同上***\n\n***size: 为多个顶点坐标的集合数组***\n\n***usage: 表示程序将如何使用缓存区中的数据***\n- gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次\n- gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次\n- gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次\n\n缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中***getAttribLocation***函数获取着色器中的attribute类型变量，并且通过***vertexAttribPointer***将其赋值改变，从而达到改变图像呈现。\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a>\n\n***param: webgl之前创建的进程***\n\n***name: 变量名称***\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a>\n\n***name: 指定要赋值的attribute变量位置***\n\n***size: 指定每个顶点数据的分量个数（1或4）***\n\n***type: 指定传入的数据格式***\n- gl.BYTE: 字节型, 取值范围[-128, 127]\n- gl.SHORT: 短整型,取值范围[-32768, 32767]\n- gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]\n- gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]\n- gl.FLOAT: 浮点型\n\n***normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间***\n\n\n***stride: 指定相邻2个顶点间的字节数，默认为0***\n\n\n***offset: 指定缓存区对象中的偏移量，设置为0即可***\n```\n如为2，则\nnew Float32Array([\n    1.0, 1.0,\n    1.0,1.0\n])\n代表2个顶点\n如为4，则\nnew Float32Array([\n    1.0, 1.0, 1.0,1.0\n])\n代表1个顶点\n```\n\n现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用***enableVertexAttribArray***来启用对应变量。\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a>\n\n***name: 待启动的变量指针，也就是名称***\n\n所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a>\n\n***mode: 需要绘制的图像形状***\n- gl.POINTS: 绘制一个点。\n- gl.LINE_STRIP: 绘制一条直线到下一个顶点。\n- gl.LINE_LOOP: 绘制一条首尾相连的线。\n- gl.LINES: 绘制一条线。\n- gl.TRIANGLES: 绘制一个三角形。\n\n***first: 绘制的开始点***\n\n***count: 需要绘制的图形个数***\n\n让我们先来创建多个点，上一课已经讲过，WebGL的坐标与真实坐标会有一些出入，所以我们需要转换一下，并且数据我们需要使用Float32Array对象来创建，我们创建一个三维的点数据，总数为200个。\n```\nfunction createPoints() {\n    //波动最大幅度 10px;\n    var arr = [];\n    var n = 20;\n    var m = 10;\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var x = webglX(-(width/2) + i*20);\n            var y = webglY((height/2) - j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n        }\n    }\n    return new Float32Array(arr)\n}\n```\n\n接下来我们使用数据缓存区来讲此200个点一次渲染出来\n```\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, createPoints(), gl.STATIC_DRAW);\n我们先获取到对应的顶点着色器中的变量\nvar a_position = gl.getAttribLocation(gl.program, 'a_Position');\n//我们需要设置数据中的点的维度。否则会解析出错。\ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(a_position);\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\n//我们需要确定绘制的具体点的数量\ngl.drawArrays(gl.POINTS, 0 , 200);\n```\n\n看看屏幕吧，是不是出来了好多点？没错你已经成功的掌握了着色器基本编程以及数据缓存区的知识。\n\n![我是图片的Alt](/assets/img/yanglei11-1.jpg)\n我们掌握了这些知识之后，下一章让我们先来使用这些内容创建一个点的波浪吧。\n\n\n#### 参考资料\n\n[1] https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform","source":"_posts/2018-04-13-yanglei11.md","raw":"---\ntitle: WebGL进阶\ndate: {{ date }}\nauthor: leo\ntags: js\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。\n---\n\n程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。（如不知道怎么创建WebGL，可参考上篇文章，点击走起）\n\n首先让我来介绍2个变量，我们需要借助这2个变量搭建的桥梁才能使JavaScript与GLSL ES之间进行沟通。\n\n- attribute： 用于顶点点着色器（**Vertex Shader**）传值时使用。\n- uniform：可用于顶点着色器（**Vertex Shader**）与片元着色器（**Fragment Shader**）使用。\n\n#### 将顶点动态化\n先在顶点着色器代码中，将对应的vec4的固定值变成变量\n```\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = 10.0;\\n' + \n  '}\\n';\n```\n\n位置参数使用了**attribute**变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。\n\n使用WebGL来获取对应参数的存储地址地址\n```\n//返回对应的地址信息\nvar aPosition = gl.getAttribLocation(gl.program, 'a_Position');\n//判断地址是否获取成功\nif(aPosition < 0) {\n    console.log('没有获取到对应position');\n}\n```\n\n然后给变量赋值\n```\ngl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);\n//或者使用Float32Array来传参\nvar p = new Float32Array([1.0, 1.0, 1.0]);\ngl.vertexAttrib3fv(aPosition, p);\n```\n\n    注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\n    vertexAttrib函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    v：表示传如的为一个vector变量。\n\n也就是说对应设置顶点着色器的函数有一下几种功能，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a>**：\n\n- void gl.vertexAttrib1f(index, v0);\n- void gl.vertexAttrib2f(index, v0, v1);\n- void gl.vertexAttrib3f(index, v0, v1, v2);\n- void gl.vertexAttrib4f(index, v0, v1, v2, v3);\n\n- void gl.vertexAttrib1fv(index, value);\n- void gl.vertexAttrib2fv(index, value);\n- void gl.vertexAttrib3fv(index, value);\n- void gl.vertexAttrib4fv(index, value);\n\n同样操作可以如下修改PointSize：\n```\n//着色器中添加变量\nvar VSHADER_SOURCE = \n  'attribute vec4 a_Position;\\n' +\n  'attribute float a_PointSize;\\n' +\n  'void main() {\\n' +\n    '  gl_Position = a_Position;\\n' +\n    '  gl_PointSize = a_PointSize;\\n' + \n  '}\\n';\nvar aPointSize = gl.getAttribLocation(gl.program, 'a_PointSize');\ngl.vertexAttrib1f(aPointSize, 10.0);\n```\n\n#### 片元着色器编程\n对片元着色器变成需要使用uniform变量来承载。\n```\n var FSHADER_SOURCE =\n'precision mediump float;\\n'+\n'uniform vec4 vColor;\\n'+\n'void main() {\\n' +\n'  gl_FragColor = vColor;\\n' + // Set the point color\n'}\\n';\n```\n获取片元着色器变量地址\n```\nvar vColor = gl.getUniformLocation(gl.program, 'vColor');\n```\n给变量赋值\n```\ngl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);\n//或使用Float32Array来传参\nvar color = new Float32Array([1.0, 0.0, 0.0, 1.0]);\ngl.uniform4fv(vColor,color)\n```\n\n    注意：uniform3fv这个函数是典型的GLSL语法命名规范，\n    uniform3fv函数功能，\n    3：对应需要传3个参数，或者是几维向量，\n    f：表示参数是float类型，\n    u：表示参数是Uint32Array类型，\n    i：表示参数是integer类型，\n    ui：表示参数是unsigned integer类型，\n    v：表示传如的为一个vector变量。\n\nuniform对应函数同attribute的函数构成相似，这里就不详细列举，具体请参考 [1]，**<a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a>**\n\n>着色器中的代码**precision mediump float;**表示的意思是着色器中配置的float对象会占用中等尺寸内存。\n具体包含的尺寸：\n- highp for vertex positions,\n- mediump for texture coordinates,\n- lowp for colors.\n\n如果不设置此参数会报错：\n\n![我是图片的Alt](/assets/img/yanglei8.jpg)\n\n\n我们可以绘制自定义的点了，接下来我们就可以尝试绘制大批量点来达到波浪的基础效果，但是之前的操作都是针对一个点的，如何可以同时绘制多个订点呢，如果你的回答是循环数据，BINGGO，没错这样你的确是可以达到这个目的，但是不是我们接下来要讲的，因为在3D绘制的时候是会经常出现大批量点、线、面的绘制的，所以WebGL提供了一种承载机制来达到传递多点的能力，说了这么多，也让我们来看看它到底是什么吧\n\n### 缓存区对象\n之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：***缓存区对象（buffer data）***,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。\n\n#### 使用缓存区步骤\n- 创建缓存区对象(gl.createBuffer())\n- 绑定缓存区对象(gl.bindBuffer())\n- 将数据写入缓存区对象(gl.bufferData())\n- 将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())\n- 开启attribute变量(gl.enableVertexAttribArray())\n\n我们需要进行缓冲区的操作：\n首先，需要创建一个缓冲区来承载大量顶点的坐标\n（代码继续上文）\n```\n// 创建缓存区 \nvar vertexBuffer = gl.createBuffer();\nif(!vertexBuffer) {\n    log('创建缓存区失败。');\n    return -1;\n}\n// 将创建的缓存区对象绑定到target表示的目标上 \ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n// 开辟存储空间，向绑定在target上的缓存区对象中写入数据 \ngl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n// 获取着色器中的变量值 \nvar a_position = gl.getAttribLocation(gl.program, 'a_p');\n// 将缓存区对象绑定到着色器变量中 \ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n// 启用缓存区 \ngl.enableVertexAttribArray(a_position);\n// 绘制缓存区中画的多个顶点 \ngl.drawArrays(gl.POINTS, 0 , array);\n```\n\n看完了绘制过程，让我们来拆解一下具体内容：\n\n首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，***bingBuffer***就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。\n#### <a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a>\n\n***target: 指定存储缓存区的目标类型***\n- gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据\n- gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值\n\n***buffer: 自己创建的缓存区对象***\n\n接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用***Float32Array***类型来创建支持GLSL的数据。使用***bufferData***函数将数据放入缓存区内。\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a>\n\n***target: 同上***\n\n***size: 为多个顶点坐标的集合数组***\n\n***usage: 表示程序将如何使用缓存区中的数据***\n- gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次\n- gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次\n- gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次\n\n缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中***getAttribLocation***函数获取着色器中的attribute类型变量，并且通过***vertexAttribPointer***将其赋值改变，从而达到改变图像呈现。\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a>\n\n***param: webgl之前创建的进程***\n\n***name: 变量名称***\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a>\n\n***name: 指定要赋值的attribute变量位置***\n\n***size: 指定每个顶点数据的分量个数（1或4）***\n\n***type: 指定传入的数据格式***\n- gl.BYTE: 字节型, 取值范围[-128, 127]\n- gl.SHORT: 短整型,取值范围[-32768, 32767]\n- gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]\n- gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]\n- gl.FLOAT: 浮点型\n\n***normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间***\n\n\n***stride: 指定相邻2个顶点间的字节数，默认为0***\n\n\n***offset: 指定缓存区对象中的偏移量，设置为0即可***\n```\n如为2，则\nnew Float32Array([\n    1.0, 1.0,\n    1.0,1.0\n])\n代表2个顶点\n如为4，则\nnew Float32Array([\n    1.0, 1.0, 1.0,1.0\n])\n代表1个顶点\n```\n\n现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用***enableVertexAttribArray***来启用对应变量。\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a>\n\n***name: 待启动的变量指针，也就是名称***\n\n所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点\n\n#### <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a>\n\n***mode: 需要绘制的图像形状***\n- gl.POINTS: 绘制一个点。\n- gl.LINE_STRIP: 绘制一条直线到下一个顶点。\n- gl.LINE_LOOP: 绘制一条首尾相连的线。\n- gl.LINES: 绘制一条线。\n- gl.TRIANGLES: 绘制一个三角形。\n\n***first: 绘制的开始点***\n\n***count: 需要绘制的图形个数***\n\n让我们先来创建多个点，上一课已经讲过，WebGL的坐标与真实坐标会有一些出入，所以我们需要转换一下，并且数据我们需要使用Float32Array对象来创建，我们创建一个三维的点数据，总数为200个。\n```\nfunction createPoints() {\n    //波动最大幅度 10px;\n    var arr = [];\n    var n = 20;\n    var m = 10;\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var x = webglX(-(width/2) + i*20);\n            var y = webglY((height/2) - j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n        }\n    }\n    return new Float32Array(arr)\n}\n```\n\n接下来我们使用数据缓存区来讲此200个点一次渲染出来\n```\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, createPoints(), gl.STATIC_DRAW);\n我们先获取到对应的顶点着色器中的变量\nvar a_position = gl.getAttribLocation(gl.program, 'a_Position');\n//我们需要设置数据中的点的维度。否则会解析出错。\ngl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(a_position);\ngl.clearColor(0.0,0.0,0.0,1.0);\ngl.clear(gl.COLOR_BUFFER_BIT);\n//我们需要确定绘制的具体点的数量\ngl.drawArrays(gl.POINTS, 0 , 200);\n```\n\n看看屏幕吧，是不是出来了好多点？没错你已经成功的掌握了着色器基本编程以及数据缓存区的知识。\n\n![我是图片的Alt](/assets/img/yanglei11-1.jpg)\n我们掌握了这些知识之后，下一章让我们先来使用这些内容创建一个点的波浪吧。\n\n\n#### 参考资料\n\n[1] https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform","slug":"2018-04-13-yanglei11","published":1,"updated":"2018-06-17T07:41:40.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo5g000ro89k5ggd0ysu","content":"<p>程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。（如不知道怎么创建WebGL，可参考上篇文章，点击走起）</p>\n<p>首先让我来介绍2个变量，我们需要借助这2个变量搭建的桥梁才能使JavaScript与GLSL ES之间进行沟通。</p>\n<ul>\n<li>attribute： 用于顶点点着色器（<strong>Vertex Shader</strong>）传值时使用。</li>\n<li>uniform：可用于顶点着色器（<strong>Vertex Shader</strong>）与片元着色器（<strong>Fragment Shader</strong>）使用。</li>\n</ul>\n<h4 id=\"将顶点动态化\"><a href=\"#将顶点动态化\" class=\"headerlink\" title=\"将顶点动态化\"></a>将顶点动态化</h4><p>先在顶点着色器代码中，将对应的vec4的固定值变成变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>位置参数使用了<strong>attribute</strong>变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。</p>\n<p>使用WebGL来获取对应参数的存储地址地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回对应的地址信息</span><br><span class=\"line\">var aPosition = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//判断地址是否获取成功</span><br><span class=\"line\">if(aPosition &lt; 0) &#123;</span><br><span class=\"line\">    console.log(&apos;没有获取到对应position&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);</span><br><span class=\"line\">//或者使用Float32Array来传参</span><br><span class=\"line\">var p = new Float32Array([1.0, 1.0, 1.0]);</span><br><span class=\"line\">gl.vertexAttrib3fv(aPosition, p);</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\nvertexAttrib函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>也就是说对应设置顶点着色器的函数有一下几种功能，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a></strong>：</p>\n<ul>\n<li>void gl.vertexAttrib1f(index, v0);</li>\n<li>void gl.vertexAttrib2f(index, v0, v1);</li>\n<li>void gl.vertexAttrib3f(index, v0, v1, v2);</li>\n<li><p>void gl.vertexAttrib4f(index, v0, v1, v2, v3);</p>\n</li>\n<li><p>void gl.vertexAttrib1fv(index, value);</p>\n</li>\n<li>void gl.vertexAttrib2fv(index, value);</li>\n<li>void gl.vertexAttrib3fv(index, value);</li>\n<li>void gl.vertexAttrib4fv(index, value);</li>\n</ul>\n<p>同样操作可以如下修改PointSize：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//着色器中添加变量</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;attribute float a_PointSize;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = a_PointSize;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var aPointSize = gl.getAttribLocation(gl.program, &apos;a_PointSize&apos;);</span><br><span class=\"line\">gl.vertexAttrib1f(aPointSize, 10.0);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"片元着色器编程\"><a href=\"#片元着色器编程\" class=\"headerlink\" title=\"片元着色器编程\"></a>片元着色器编程</h4><p>对片元着色器变成需要使用uniform变量来承载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">&apos;precision mediump float;\\n&apos;+</span><br><span class=\"line\">&apos;uniform vec4 vColor;\\n&apos;+</span><br><span class=\"line\">&apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">&apos;  gl_FragColor = vColor;\\n&apos; + // Set the point color</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>获取片元着色器变量地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vColor = gl.getUniformLocation(gl.program, &apos;vColor&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">//或使用Float32Array来传参</span><br><span class=\"line\">var color = new Float32Array([1.0, 0.0, 0.0, 1.0]);</span><br><span class=\"line\">gl.uniform4fv(vColor,color)</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：uniform3fv这个函数是典型的GLSL语法命名规范，\nuniform3fv函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nu：表示参数是Uint32Array类型，\ni：表示参数是integer类型，\nui：表示参数是unsigned integer类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>uniform对应函数同attribute的函数构成相似，这里就不详细列举，具体请参考 [1]，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a></strong></p>\n<blockquote>\n<p>着色器中的代码<strong>precision mediump float;</strong>表示的意思是着色器中配置的float对象会占用中等尺寸内存。<br>具体包含的尺寸：</p>\n<ul>\n<li>highp for vertex positions,</li>\n<li>mediump for texture coordinates,</li>\n<li>lowp for colors.</li>\n</ul>\n</blockquote>\n<p>如果不设置此参数会报错：</p>\n<p><img src=\"/assets/img/yanglei8.jpg\" alt=\"我是图片的Alt\"></p>\n<p>我们可以绘制自定义的点了，接下来我们就可以尝试绘制大批量点来达到波浪的基础效果，但是之前的操作都是针对一个点的，如何可以同时绘制多个订点呢，如果你的回答是循环数据，BINGGO，没错这样你的确是可以达到这个目的，但是不是我们接下来要讲的，因为在3D绘制的时候是会经常出现大批量点、线、面的绘制的，所以WebGL提供了一种承载机制来达到传递多点的能力，说了这么多，也让我们来看看它到底是什么吧</p>\n<h3 id=\"缓存区对象\"><a href=\"#缓存区对象\" class=\"headerlink\" title=\"缓存区对象\"></a>缓存区对象</h3><p>之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：<strong><em>缓存区对象（buffer data）</em></strong>,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。</p>\n<h4 id=\"使用缓存区步骤\"><a href=\"#使用缓存区步骤\" class=\"headerlink\" title=\"使用缓存区步骤\"></a>使用缓存区步骤</h4><ul>\n<li>创建缓存区对象(gl.createBuffer())</li>\n<li>绑定缓存区对象(gl.bindBuffer())</li>\n<li>将数据写入缓存区对象(gl.bufferData())</li>\n<li>将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())</li>\n<li>开启attribute变量(gl.enableVertexAttribArray())</li>\n</ul>\n<p>我们需要进行缓冲区的操作：<br>首先，需要创建一个缓冲区来承载大量顶点的坐标<br>（代码继续上文）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建缓存区 </span><br><span class=\"line\">var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">if(!vertexBuffer) &#123;</span><br><span class=\"line\">    log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将创建的缓存区对象绑定到target表示的目标上 </span><br><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">// 开辟存储空间，向绑定在target上的缓存区对象中写入数据 </span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">// 获取着色器中的变量值 </span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">// 将缓存区对象绑定到着色器变量中 </span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">// 启用缓存区 </span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">// 绘制缓存区中画的多个顶点 </span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , array);</span><br></pre></td></tr></table></figure></p>\n<p>看完了绘制过程，让我们来拆解一下具体内容：</p>\n<p>首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，<strong><em>bingBuffer</em></strong>就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。</p>\n<h4 id=\"gl-bindBuffer-target-buffer\"><a href=\"#gl-bindBuffer-target-buffer\" class=\"headerlink\" title=\"gl.bindBuffer(target, buffer)\"></a><a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a></h4><p><strong><em>target: 指定存储缓存区的目标类型</em></strong></p>\n<ul>\n<li>gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据</li>\n<li>gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值</li>\n</ul>\n<p><strong><em>buffer: 自己创建的缓存区对象</em></strong></p>\n<p>接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用<strong><em>Float32Array</em></strong>类型来创建支持GLSL的数据。使用<strong><em>bufferData</em></strong>函数将数据放入缓存区内。</p>\n<h4 id=\"gl-bufferData-target-size-usage\"><a href=\"#gl-bufferData-target-size-usage\" class=\"headerlink\" title=\"gl.bufferData(target, size, usage)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a></h4><p><strong><em>target: 同上</em></strong></p>\n<p><strong><em>size: 为多个顶点坐标的集合数组</em></strong></p>\n<p><strong><em>usage: 表示程序将如何使用缓存区中的数据</em></strong></p>\n<ul>\n<li>gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次</li>\n<li>gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次</li>\n<li>gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次</li>\n</ul>\n<p>缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中<strong><em>getAttribLocation</em></strong>函数获取着色器中的attribute类型变量，并且通过<strong><em>vertexAttribPointer</em></strong>将其赋值改变，从而达到改变图像呈现。</p>\n<h4 id=\"gl-getAttribLocation-program-name\"><a href=\"#gl-getAttribLocation-program-name\" class=\"headerlink\" title=\"gl.getAttribLocation(program,name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a></h4><p><strong><em>param: webgl之前创建的进程</em></strong></p>\n<p><strong><em>name: 变量名称</em></strong></p>\n<h4 id=\"gl-vertexAttribPointer-name-size-type-normalized-stride-offset\"><a href=\"#gl-vertexAttribPointer-name-size-type-normalized-stride-offset\" class=\"headerlink\" title=\"gl.vertexAttribPointer(name, size, type, normalized, stride, offset)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a></h4><p><strong><em>name: 指定要赋值的attribute变量位置</em></strong></p>\n<p><strong><em>size: 指定每个顶点数据的分量个数（1或4）</em></strong></p>\n<p><strong><em>type: 指定传入的数据格式</em></strong></p>\n<ul>\n<li>gl.BYTE: 字节型, 取值范围[-128, 127]</li>\n<li>gl.SHORT: 短整型,取值范围[-32768, 32767]</li>\n<li>gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]</li>\n<li>gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]</li>\n<li>gl.FLOAT: 浮点型</li>\n</ul>\n<p><strong><em>normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间</em></strong></p>\n<p><strong><em>stride: 指定相邻2个顶点间的字节数，默认为0</em></strong></p>\n<p><strong><em>offset: 指定缓存区对象中的偏移量，设置为0即可</em></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如为2，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0,</span><br><span class=\"line\">    1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表2个顶点</span><br><span class=\"line\">如为4，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0, 1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表1个顶点</span><br></pre></td></tr></table></figure></p>\n<p>现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用<strong><em>enableVertexAttribArray</em></strong>来启用对应变量。</p>\n<h4 id=\"gl-enableVertexAttribArray-name\"><a href=\"#gl-enableVertexAttribArray-name\" class=\"headerlink\" title=\"gl.enableVertexAttribArray(name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a></h4><p><strong><em>name: 待启动的变量指针，也就是名称</em></strong></p>\n<p>所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点</p>\n<h4 id=\"gl-drawArrays-mode-first-count\"><a href=\"#gl-drawArrays-mode-first-count\" class=\"headerlink\" title=\"gl.drawArrays(mode, first, count)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a></h4><p><strong><em>mode: 需要绘制的图像形状</em></strong></p>\n<ul>\n<li>gl.POINTS: 绘制一个点。</li>\n<li>gl.LINE_STRIP: 绘制一条直线到下一个顶点。</li>\n<li>gl.LINE_LOOP: 绘制一条首尾相连的线。</li>\n<li>gl.LINES: 绘制一条线。</li>\n<li>gl.TRIANGLES: 绘制一个三角形。</li>\n</ul>\n<p><strong><em>first: 绘制的开始点</em></strong></p>\n<p><strong><em>count: 需要绘制的图形个数</em></strong></p>\n<p>让我们先来创建多个点，上一课已经讲过，WebGL的坐标与真实坐标会有一些出入，所以我们需要转换一下，并且数据我们需要使用Float32Array对象来创建，我们创建一个三维的点数据，总数为200个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createPoints() &#123;</span><br><span class=\"line\">    //波动最大幅度 10px;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var n = 20;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var x = webglX(-(width/2) + i*20);</span><br><span class=\"line\">            var y = webglY((height/2) - j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Float32Array(arr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们使用数据缓存区来讲此200个点一次渲染出来<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, createPoints(), gl.STATIC_DRAW);</span><br><span class=\"line\">我们先获取到对应的顶点着色器中的变量</span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//我们需要设置数据中的点的维度。否则会解析出错。</span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">//我们需要确定绘制的具体点的数量</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , 200);</span><br></pre></td></tr></table></figure></p>\n<p>看看屏幕吧，是不是出来了好多点？没错你已经成功的掌握了着色器基本编程以及数据缓存区的知识。</p>\n<p><img src=\"/assets/img/yanglei11-1.jpg\" alt=\"我是图片的Alt\"><br>我们掌握了这些知识之后，下一章让我们先来使用这些内容创建一个点的波浪吧。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p>[1] <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>程序创建完之后，我们需要需要对着色器进行动态控制才能达到我们所需要的功能。（如不知道怎么创建WebGL，可参考上篇文章，点击走起）</p>\n<p>首先让我来介绍2个变量，我们需要借助这2个变量搭建的桥梁才能使JavaScript与GLSL ES之间进行沟通。</p>\n<ul>\n<li>attribute： 用于顶点点着色器（<strong>Vertex Shader</strong>）传值时使用。</li>\n<li>uniform：可用于顶点着色器（<strong>Vertex Shader</strong>）与片元着色器（<strong>Fragment Shader</strong>）使用。</li>\n</ul>\n<h4 id=\"将顶点动态化\"><a href=\"#将顶点动态化\" class=\"headerlink\" title=\"将顶点动态化\"></a>将顶点动态化</h4><p>先在顶点着色器代码中，将对应的vec4的固定值变成变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = 10.0;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>位置参数使用了<strong>attribute</strong>变量来承载。这样WebGL对象就可以获取到对应的存储位置，就可以去动态改变GLSL变量了。</p>\n<p>使用WebGL来获取对应参数的存储地址地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回对应的地址信息</span><br><span class=\"line\">var aPosition = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//判断地址是否获取成功</span><br><span class=\"line\">if(aPosition &lt; 0) &#123;</span><br><span class=\"line\">    console.log(&apos;没有获取到对应position&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.vertexAttrib3f(aPosition, 1.0, 1.0, 0.0);</span><br><span class=\"line\">//或者使用Float32Array来传参</span><br><span class=\"line\">var p = new Float32Array([1.0, 1.0, 1.0]);</span><br><span class=\"line\">gl.vertexAttrib3fv(aPosition, p);</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：vertexAttrib3fv这个函数是典型的GLSL语法命名规范，\nvertexAttrib函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>也就是说对应设置顶点着色器的函数有一下几种功能，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttrib\">参考文档</a></strong>：</p>\n<ul>\n<li>void gl.vertexAttrib1f(index, v0);</li>\n<li>void gl.vertexAttrib2f(index, v0, v1);</li>\n<li>void gl.vertexAttrib3f(index, v0, v1, v2);</li>\n<li><p>void gl.vertexAttrib4f(index, v0, v1, v2, v3);</p>\n</li>\n<li><p>void gl.vertexAttrib1fv(index, value);</p>\n</li>\n<li>void gl.vertexAttrib2fv(index, value);</li>\n<li>void gl.vertexAttrib3fv(index, value);</li>\n<li>void gl.vertexAttrib4fv(index, value);</li>\n</ul>\n<p>同样操作可以如下修改PointSize：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//着色器中添加变量</span><br><span class=\"line\">var VSHADER_SOURCE = </span><br><span class=\"line\">  &apos;attribute vec4 a_Position;\\n&apos; +</span><br><span class=\"line\">  &apos;attribute float a_PointSize;\\n&apos; +</span><br><span class=\"line\">  &apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_Position = a_Position;\\n&apos; +</span><br><span class=\"line\">    &apos;  gl_PointSize = a_PointSize;\\n&apos; + </span><br><span class=\"line\">  &apos;&#125;\\n&apos;;</span><br><span class=\"line\">var aPointSize = gl.getAttribLocation(gl.program, &apos;a_PointSize&apos;);</span><br><span class=\"line\">gl.vertexAttrib1f(aPointSize, 10.0);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"片元着色器编程\"><a href=\"#片元着色器编程\" class=\"headerlink\" title=\"片元着色器编程\"></a>片元着色器编程</h4><p>对片元着色器变成需要使用uniform变量来承载。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var FSHADER_SOURCE =</span><br><span class=\"line\">&apos;precision mediump float;\\n&apos;+</span><br><span class=\"line\">&apos;uniform vec4 vColor;\\n&apos;+</span><br><span class=\"line\">&apos;void main() &#123;\\n&apos; +</span><br><span class=\"line\">&apos;  gl_FragColor = vColor;\\n&apos; + // Set the point color</span><br><span class=\"line\">&apos;&#125;\\n&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>获取片元着色器变量地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vColor = gl.getUniformLocation(gl.program, &apos;vColor&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>给变量赋值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.uniform4f(vColor, 1.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">//或使用Float32Array来传参</span><br><span class=\"line\">var color = new Float32Array([1.0, 0.0, 0.0, 1.0]);</span><br><span class=\"line\">gl.uniform4fv(vColor,color)</span><br></pre></td></tr></table></figure></p>\n<pre><code>注意：uniform3fv这个函数是典型的GLSL语法命名规范，\nuniform3fv函数功能，\n3：对应需要传3个参数，或者是几维向量，\nf：表示参数是float类型，\nu：表示参数是Uint32Array类型，\ni：表示参数是integer类型，\nui：表示参数是unsigned integer类型，\nv：表示传如的为一个vector变量。\n</code></pre><p>uniform对应函数同attribute的函数构成相似，这里就不详细列举，具体请参考 [1]，<strong><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\">参考文档</a></strong></p>\n<blockquote>\n<p>着色器中的代码<strong>precision mediump float;</strong>表示的意思是着色器中配置的float对象会占用中等尺寸内存。<br>具体包含的尺寸：</p>\n<ul>\n<li>highp for vertex positions,</li>\n<li>mediump for texture coordinates,</li>\n<li>lowp for colors.</li>\n</ul>\n</blockquote>\n<p>如果不设置此参数会报错：</p>\n<p><img src=\"/assets/img/yanglei8.jpg\" alt=\"我是图片的Alt\"></p>\n<p>我们可以绘制自定义的点了，接下来我们就可以尝试绘制大批量点来达到波浪的基础效果，但是之前的操作都是针对一个点的，如何可以同时绘制多个订点呢，如果你的回答是循环数据，BINGGO，没错这样你的确是可以达到这个目的，但是不是我们接下来要讲的，因为在3D绘制的时候是会经常出现大批量点、线、面的绘制的，所以WebGL提供了一种承载机制来达到传递多点的能力，说了这么多，也让我们来看看它到底是什么吧</p>\n<h3 id=\"缓存区对象\"><a href=\"#缓存区对象\" class=\"headerlink\" title=\"缓存区对象\"></a>缓存区对象</h3><p>之前的方式可以通过循环来绘制多个点，一次需要绘制多个点，需要同时传递进去多个点的数据。刚好，在WebGL中提供了一种机制：<strong><em>缓存区对象（buffer data）</em></strong>,缓存区对象可以同时向着色器传递多个顶点坐标。缓存区是WebGL中的一块内存区域，我们可以向里面存放大量顶点坐标数据，可随时供着色器使用。</p>\n<h4 id=\"使用缓存区步骤\"><a href=\"#使用缓存区步骤\" class=\"headerlink\" title=\"使用缓存区步骤\"></a>使用缓存区步骤</h4><ul>\n<li>创建缓存区对象(gl.createBuffer())</li>\n<li>绑定缓存区对象(gl.bindBuffer())</li>\n<li>将数据写入缓存区对象(gl.bufferData())</li>\n<li>将缓存区对象分配给一个attribute变量(gl.vertexAttribPointer())</li>\n<li>开启attribute变量(gl.enableVertexAttribArray())</li>\n</ul>\n<p>我们需要进行缓冲区的操作：<br>首先，需要创建一个缓冲区来承载大量顶点的坐标<br>（代码继续上文）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建缓存区 </span><br><span class=\"line\">var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">if(!vertexBuffer) &#123;</span><br><span class=\"line\">    log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将创建的缓存区对象绑定到target表示的目标上 </span><br><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">// 开辟存储空间，向绑定在target上的缓存区对象中写入数据 </span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">// 获取着色器中的变量值 </span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">// 将缓存区对象绑定到着色器变量中 </span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">// 启用缓存区 </span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">// 绘制缓存区中画的多个顶点 </span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , array);</span><br></pre></td></tr></table></figure></p>\n<p>看完了绘制过程，让我们来拆解一下具体内容：</p>\n<p>首先，我们要在茫茫内存中申请一个区域来放置缓存区对象的内容，但是我们无法直接放置缓存对象进入内存中，否则会无法识别对应的数据类型，从而无法达到存取自如的境界，那我们就需要将数据的类型告知内存，<strong><em>bingBuffer</em></strong>就是为解决此问题诞生的，函数会在内存中申请一部分区域，并且通过target来制定数据类型，也就是说，缓存区是需要放置在target表示的类型部分去存储。</p>\n<h4 id=\"gl-bindBuffer-target-buffer\"><a href=\"#gl-bindBuffer-target-buffer\" class=\"headerlink\" title=\"gl.bindBuffer(target, buffer)\"></a><a target=\"_blank\" href=\"//developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\">gl.bindBuffer(target, buffer)</a></h4><p><strong><em>target: 指定存储缓存区的目标类型</em></strong></p>\n<ul>\n<li>gl.ARRAY_BUFFER : 指缓存区中包含了顶点的数据</li>\n<li>gl.ELEMENT_ARRAY_BUFFER : 指缓存区中包含了顶点数据的索引值</li>\n</ul>\n<p><strong><em>buffer: 自己创建的缓存区对象</em></strong></p>\n<p>接下来，我们需要做的是填充刚刚申请的缓存区，我们需要使用一个符合GLSL语法的数据格式，Javascript中可用<strong><em>Float32Array</em></strong>类型来创建支持GLSL的数据。使用<strong><em>bufferData</em></strong>函数将数据放入缓存区内。</p>\n<h4 id=\"gl-bufferData-target-size-usage\"><a href=\"#gl-bufferData-target-size-usage\" class=\"headerlink\" title=\"gl.bufferData(target, size, usage)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\">gl.bufferData(target, size, usage)</a></h4><p><strong><em>target: 同上</em></strong></p>\n<p><strong><em>size: 为多个顶点坐标的集合数组</em></strong></p>\n<p><strong><em>usage: 表示程序将如何使用缓存区中的数据</em></strong></p>\n<ul>\n<li>gl.STATIC_DRAW : 只会向缓存区对象中写入一次数据，但需要绘制很多次</li>\n<li>gl.STREAM_DRAW : 只会向缓存区对象中写入一次数据，然后绘制若干次</li>\n<li>gl.DYNAMIC_DRAW : 会想缓存区对象中多次写入数据，并绘制很多次</li>\n</ul>\n<p>缓存区中已经存储了多个顶点坐标，接下来我们需要将此数据运用到对应的着色器上，才能真正的绘制出来可视化图像，如何传递呢？首先我们需要在着色器中建立一个attribute类型的变量以方便我们操作，着色器中的对象，着色器中存在对象之后，我们可以使用Javascript中<strong><em>getAttribLocation</em></strong>函数获取着色器中的attribute类型变量，并且通过<strong><em>vertexAttribPointer</em></strong>将其赋值改变，从而达到改变图像呈现。</p>\n<h4 id=\"gl-getAttribLocation-program-name\"><a href=\"#gl-getAttribLocation-program-name\" class=\"headerlink\" title=\"gl.getAttribLocation(program,name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation\">gl.getAttribLocation(program,name)</a></h4><p><strong><em>param: webgl之前创建的进程</em></strong></p>\n<p><strong><em>name: 变量名称</em></strong></p>\n<h4 id=\"gl-vertexAttribPointer-name-size-type-normalized-stride-offset\"><a href=\"#gl-vertexAttribPointer-name-size-type-normalized-stride-offset\" class=\"headerlink\" title=\"gl.vertexAttribPointer(name, size, type, normalized, stride, offset)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\">gl.vertexAttribPointer(name, size, type, normalized, stride, offset)</a></h4><p><strong><em>name: 指定要赋值的attribute变量位置</em></strong></p>\n<p><strong><em>size: 指定每个顶点数据的分量个数（1或4）</em></strong></p>\n<p><strong><em>type: 指定传入的数据格式</em></strong></p>\n<ul>\n<li>gl.BYTE: 字节型, 取值范围[-128, 127]</li>\n<li>gl.SHORT: 短整型,取值范围[-32768, 32767]</li>\n<li>gl.UNSIGNED_BYTE: 无符号字节型,取值范围[0, 255]</li>\n<li>gl.UNSIGNED_SHORT: 无符号短整型, 取值范围[0, 65535]</li>\n<li>gl.FLOAT: 浮点型</li>\n</ul>\n<p><strong><em>normalized: 表明是否将非浮点数的数据归入到[0, 1]或[-1, 1]区间</em></strong></p>\n<p><strong><em>stride: 指定相邻2个顶点间的字节数，默认为0</em></strong></p>\n<p><strong><em>offset: 指定缓存区对象中的偏移量，设置为0即可</em></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如为2，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0,</span><br><span class=\"line\">    1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表2个顶点</span><br><span class=\"line\">如为4，则</span><br><span class=\"line\">new Float32Array([</span><br><span class=\"line\">    1.0, 1.0, 1.0,1.0</span><br><span class=\"line\">])</span><br><span class=\"line\">代表1个顶点</span><br></pre></td></tr></table></figure></p>\n<p>现在缓存区已经存在多个顶点数据，接下来我们来启用携带缓存区数据的attribute变量，使用<strong><em>enableVertexAttribArray</em></strong>来启用对应变量。</p>\n<h4 id=\"gl-enableVertexAttribArray-name\"><a href=\"#gl-enableVertexAttribArray-name\" class=\"headerlink\" title=\"gl.enableVertexAttribArray(name)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\">gl.enableVertexAttribArray(name)</a></h4><p><strong><em>name: 待启动的变量指针，也就是名称</em></strong></p>\n<p>所有的缓存区操作步骤我们都已经完成，那么接下来我们可以绘制出缓存区中的多个顶点</p>\n<h4 id=\"gl-drawArrays-mode-first-count\"><a href=\"#gl-drawArrays-mode-first-count\" class=\"headerlink\" title=\"gl.drawArrays(mode, first, count)\"></a><a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays\">gl.drawArrays(mode, first, count)</a></h4><p><strong><em>mode: 需要绘制的图像形状</em></strong></p>\n<ul>\n<li>gl.POINTS: 绘制一个点。</li>\n<li>gl.LINE_STRIP: 绘制一条直线到下一个顶点。</li>\n<li>gl.LINE_LOOP: 绘制一条首尾相连的线。</li>\n<li>gl.LINES: 绘制一条线。</li>\n<li>gl.TRIANGLES: 绘制一个三角形。</li>\n</ul>\n<p><strong><em>first: 绘制的开始点</em></strong></p>\n<p><strong><em>count: 需要绘制的图形个数</em></strong></p>\n<p>让我们先来创建多个点，上一课已经讲过，WebGL的坐标与真实坐标会有一些出入，所以我们需要转换一下，并且数据我们需要使用Float32Array对象来创建，我们创建一个三维的点数据，总数为200个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createPoints() &#123;</span><br><span class=\"line\">    //波动最大幅度 10px;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var n = 20;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var x = webglX(-(width/2) + i*20);</span><br><span class=\"line\">            var y = webglY((height/2) - j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Float32Array(arr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们使用数据缓存区来讲此200个点一次渲染出来<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">gl.bufferData(gl.ARRAY_BUFFER, createPoints(), gl.STATIC_DRAW);</span><br><span class=\"line\">我们先获取到对应的顶点着色器中的变量</span><br><span class=\"line\">var a_position = gl.getAttribLocation(gl.program, &apos;a_Position&apos;);</span><br><span class=\"line\">//我们需要设置数据中的点的维度。否则会解析出错。</span><br><span class=\"line\">gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">//我们需要确定绘制的具体点的数量</span><br><span class=\"line\">gl.drawArrays(gl.POINTS, 0 , 200);</span><br></pre></td></tr></table></figure></p>\n<p>看看屏幕吧，是不是出来了好多点？没错你已经成功的掌握了着色器基本编程以及数据缓存区的知识。</p>\n<p><img src=\"/assets/img/yanglei11-1.jpg\" alt=\"我是图片的Alt\"><br>我们掌握了这些知识之后，下一章让我们先来使用这些内容创建一个点的波浪吧。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p>[1] <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniform</a></p>\n"},{"title":"WebGL实战","date":"2018-06-17T04:29:44.044Z","author":"leo","thumbnail":null,"blogexcerpt":"前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：","_content":"\n前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：\n\n![WebGL波浪效果](/assets/img/bolang4.gif)\n\n让我们先准备一下前期的WebGL内容,首先让我们来创建一个可以接受参数的着色器，（如果不清楚具体要怎么创建可以参考上一章教程内容哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）\n接下来，我们需要创建多个点的坐标，所有点在同一行时，只有X坐标是变化的，y是相同的。\n\n但因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei12-1.jpg)\n\n然后你知道了这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：\n\n```\n//错误\n<canvas id=\"glcanvas\" style=\"width: 700px; height: 500px;\">\n//正确的方式\n<canvas id=\"glcanvas\" width=\"700\" height=\"500\">\n```\n\n首先我们需要先将对应的真实坐标转换成WebGL坐标，因为canvas宽度的一半对应为WebGL的1.0尺寸。所以将真实像素除以宽度的一半就可以得到对应的WebGL尺寸，高度与宽度的处理方式一致。\n```\nfunction webglX (num) {\n    return num/(width/2);\n};\nfunction webglY (num) {\n    return num/(height/2);\n}\n```\n\n有了点，那么我们就可以使用先前讲过的缓存区开始批量绘制点了。（如果不清楚具体如何使用缓存区绘制，也可以点击上一章哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）。\n\n接下来我们要让他动起来，怎么动起来呢？思路是我们可以在不停的重绘，并且将点进行轻微位移即可达到效果，定时执行函数可以使用***setInterval***或***setTimeout***。但此2个函数性能上有很大问题，并且也无法完美的匹配浏览器的刷新频率。\n\n在这里我跟大家介绍一个新函数***requestAnimationFrame***\n\nrequestAnimationFrame是为了提高js动画性能而诞生的神器。下面我们简单来介绍一下这个函数为何被誉为神器。\n\n> 1. requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，也就是没s刷新60次。因与浏览器刷新频率一样所以不会出现看似卡顿的情况出现。\n> 1. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量\n> 1. requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销\n\n具体的内容以后有机会可以单独详细来介绍此函数功能。\n\n接下来让我们来绘制一个变化的函数,变化值从0开始，requestAnimationFrame内容入参为循环执行的函数名。\n\n```\nvar num = 0;\nfunction render() {\n    requestAnimationFrame(render);\n    num = num - 1;\n    var data = createPoints(num);\n    setPoints(data, 1000);\n}\n```\n接下来我们需要将之前绘制点的部分功能函数提取到单独的一个函数中，方便动画循环调用时使用。\n\n```\nfunction setPoints(data, num) {\n    var vertexBuffer = gl.createBuffer();\n    if(!vertexBuffer) {\n        log('创建缓存区失败。');\n        return -1;\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n    var a_position = gl.getAttribLocation(gl.program, 'a_p');\n    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(a_position);\n    gl.clearColor(0.0,0.0,0.0,1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.POINTS, 0 , num);\n}\n```\n\n接下来也就是最重要的，我们需要每次都变更对应点的坐标位置，因我们要使用波浪效果，所以采用正弦函数来实现，首先让所有的点都按照每次变更10度的浮动，并且因为是上下移动，我们只需要变更y轴的坐标即可。\n\n```\nvar width = 700;\nvar height = 500;\nfunction createPoints(gap) {\n    var max = 10\n    var arr = [];\n    var n = 100;\n    var m = 10;\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var x = webglX(-(width/2) + i*20);\n            var y = webglY((height/2)  - j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n        }\n    }\n    return new Float32Array(arr)\n}\n```\n正弦函数Math.sin传入的值不是角度，而是弧度，我们需要通过下面的函数把角度转化为弧度，函数如下：（如果您不知道弧度与角度的关系，建议自行查询）\n```\nfunction numToDeg(num) {\n    return Math.PI*num / 180;\n};\n```\n\n我们为此函数中x与y的值进行一下操作。\n\n1.为保证所有的点肯定全部覆盖屏幕，我们将每个点的间距调整按照整个canvas宽度超过500的尺寸来平均分，整个坐标系向做便宜200，也就是右边还存在300的富于空间，这样即使有错开位移也不会让屏幕露出空白。接下来，为了让上面的点波动比下面的点大，让我们来设置了一个最大倍数，并且将行数与此倍数关联，这样就会使动画上下浮动不一样了。\n```\nvar deg = (j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n我们达到了横向\n![WebGL波浪效果](/assets/img/bolang1.gif)\n\n接下来我们在角度便宜中添加上x轴的影响力。\n```\nvar deg = (i-j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n让我们看看效果，波动开始有偏差了\n![WebGL波浪效果](/assets/img/bolang2.gif)\n\n效果按照我们预期的方向前进了，接下来我们扩大x轴的影响,这个个人可以一点一点尝试，我们直接扩大到5倍\n\n```\nvar deg = (i*5-j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n![WebGL波浪效果](/assets/img/bolang3.gif)\n\n看样子动画效果已经基本达到了效果，接下来让我们把上面的点变小，下面的点变大。产生前后的视觉差。\n如何让渲染的点尺寸不同呢？没错我们也可以使用缓存区来操作。\n对创建点的函数进行改造：\n```\n function createPoints(gap) {\n    //波动最大幅度 10px;\n    var max = 10\n    var n = 100;\n    var m = 10;\n    var arr = [];\n    var size = [];\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var deg = (i*7-j*20+gap);\n            var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\n            var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n            size.push((4-j/4));\n        }\n    }\n    return {\n        positions: new Float32Array(arr),\n        size: new Float32Array(size),\n        num: m * n\n    }\n}\n```\n我们把点与对应的坐标匹配一下，并且把点的数量动态化,让我们在使用缓存区来把size动态批量化\n```\nfunction setSize(sizes, n) {\n    var sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    var a_pointsize = gl.getAttribLocation(gl.program, 'size');\n    gl.vertexAttribPointer(a_pointsize, 1, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(a_pointsize);\n};\n```\n记得着色器上要声明一个接收的参数哦\n```\nattribute float size;\n```\n然后我们在render函数中可以直接使用其函数进行重绘了\n![WebGL波浪效果](/assets/img/bolang4.gif)\n我们已经绘制出来了最终效果，本着开源的原则，完整代码链接如下：\n\nhttps://github.com/jdf2e/webgl-demo  ","source":"_posts/2018-04-13-yanglei12.md","raw":"---\ntitle: WebGL实战\ndate: {{ date }}\nauthor: leo\ntags: js\ncategories:\n    - 技术仓库\nthumbnail:\nblogexcerpt: 前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：\n---\n\n前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：\n\n![WebGL波浪效果](/assets/img/bolang4.gif)\n\n让我们先准备一下前期的WebGL内容,首先让我们来创建一个可以接受参数的着色器，（如果不清楚具体要怎么创建可以参考上一章教程内容哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）\n接下来，我们需要创建多个点的坐标，所有点在同一行时，只有X坐标是变化的，y是相同的。\n\n但因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：\n\n![WebGL坐标系与普通canvas坐标系](/assets/img/yanglei12-1.jpg)\n\n然后你知道了这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：\n\n```\n//错误\n<canvas id=\"glcanvas\" style=\"width: 700px; height: 500px;\">\n//正确的方式\n<canvas id=\"glcanvas\" width=\"700\" height=\"500\">\n```\n\n首先我们需要先将对应的真实坐标转换成WebGL坐标，因为canvas宽度的一半对应为WebGL的1.0尺寸。所以将真实像素除以宽度的一半就可以得到对应的WebGL尺寸，高度与宽度的处理方式一致。\n```\nfunction webglX (num) {\n    return num/(width/2);\n};\nfunction webglY (num) {\n    return num/(height/2);\n}\n```\n\n有了点，那么我们就可以使用先前讲过的缓存区开始批量绘制点了。（如果不清楚具体如何使用缓存区绘制，也可以点击上一章哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）。\n\n接下来我们要让他动起来，怎么动起来呢？思路是我们可以在不停的重绘，并且将点进行轻微位移即可达到效果，定时执行函数可以使用***setInterval***或***setTimeout***。但此2个函数性能上有很大问题，并且也无法完美的匹配浏览器的刷新频率。\n\n在这里我跟大家介绍一个新函数***requestAnimationFrame***\n\nrequestAnimationFrame是为了提高js动画性能而诞生的神器。下面我们简单来介绍一下这个函数为何被誉为神器。\n\n> 1. requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，也就是没s刷新60次。因与浏览器刷新频率一样所以不会出现看似卡顿的情况出现。\n> 1. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量\n> 1. requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销\n\n具体的内容以后有机会可以单独详细来介绍此函数功能。\n\n接下来让我们来绘制一个变化的函数,变化值从0开始，requestAnimationFrame内容入参为循环执行的函数名。\n\n```\nvar num = 0;\nfunction render() {\n    requestAnimationFrame(render);\n    num = num - 1;\n    var data = createPoints(num);\n    setPoints(data, 1000);\n}\n```\n接下来我们需要将之前绘制点的部分功能函数提取到单独的一个函数中，方便动画循环调用时使用。\n\n```\nfunction setPoints(data, num) {\n    var vertexBuffer = gl.createBuffer();\n    if(!vertexBuffer) {\n        log('创建缓存区失败。');\n        return -1;\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n    var a_position = gl.getAttribLocation(gl.program, 'a_p');\n    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(a_position);\n    gl.clearColor(0.0,0.0,0.0,1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.POINTS, 0 , num);\n}\n```\n\n接下来也就是最重要的，我们需要每次都变更对应点的坐标位置，因我们要使用波浪效果，所以采用正弦函数来实现，首先让所有的点都按照每次变更10度的浮动，并且因为是上下移动，我们只需要变更y轴的坐标即可。\n\n```\nvar width = 700;\nvar height = 500;\nfunction createPoints(gap) {\n    var max = 10\n    var arr = [];\n    var n = 100;\n    var m = 10;\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var x = webglX(-(width/2) + i*20);\n            var y = webglY((height/2)  - j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n        }\n    }\n    return new Float32Array(arr)\n}\n```\n正弦函数Math.sin传入的值不是角度，而是弧度，我们需要通过下面的函数把角度转化为弧度，函数如下：（如果您不知道弧度与角度的关系，建议自行查询）\n```\nfunction numToDeg(num) {\n    return Math.PI*num / 180;\n};\n```\n\n我们为此函数中x与y的值进行一下操作。\n\n1.为保证所有的点肯定全部覆盖屏幕，我们将每个点的间距调整按照整个canvas宽度超过500的尺寸来平均分，整个坐标系向做便宜200，也就是右边还存在300的富于空间，这样即使有错开位移也不会让屏幕露出空白。接下来，为了让上面的点波动比下面的点大，让我们来设置了一个最大倍数，并且将行数与此倍数关联，这样就会使动画上下浮动不一样了。\n```\nvar deg = (j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n我们达到了横向\n![WebGL波浪效果](/assets/img/bolang1.gif)\n\n接下来我们在角度便宜中添加上x轴的影响力。\n```\nvar deg = (i-j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n让我们看看效果，波动开始有偏差了\n![WebGL波浪效果](/assets/img/bolang2.gif)\n\n效果按照我们预期的方向前进了，接下来我们扩大x轴的影响,这个个人可以一点一点尝试，我们直接扩大到5倍\n\n```\nvar deg = (i*5-j*20+gap);\nvar x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\nvar y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n```\n![WebGL波浪效果](/assets/img/bolang3.gif)\n\n看样子动画效果已经基本达到了效果，接下来让我们把上面的点变小，下面的点变大。产生前后的视觉差。\n如何让渲染的点尺寸不同呢？没错我们也可以使用缓存区来操作。\n对创建点的函数进行改造：\n```\n function createPoints(gap) {\n    //波动最大幅度 10px;\n    var max = 10\n    var n = 100;\n    var m = 10;\n    var arr = [];\n    var size = [];\n    for(var i = 0; i < n; i++) {\n        for(var j = 0; j < m; j++) {\n            var deg = (i*7-j*20+gap);\n            var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);\n            var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);\n            var z = -1;\n            var item = [x, y, z];\n            arr = arr.concat(item);\n            size.push((4-j/4));\n        }\n    }\n    return {\n        positions: new Float32Array(arr),\n        size: new Float32Array(size),\n        num: m * n\n    }\n}\n```\n我们把点与对应的坐标匹配一下，并且把点的数量动态化,让我们在使用缓存区来把size动态批量化\n```\nfunction setSize(sizes, n) {\n    var sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    var a_pointsize = gl.getAttribLocation(gl.program, 'size');\n    gl.vertexAttribPointer(a_pointsize, 1, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(a_pointsize);\n};\n```\n记得着色器上要声明一个接收的参数哦\n```\nattribute float size;\n```\n然后我们在render函数中可以直接使用其函数进行重绘了\n![WebGL波浪效果](/assets/img/bolang4.gif)\n我们已经绘制出来了最终效果，本着开源的原则，完整代码链接如下：\n\nhttps://github.com/jdf2e/webgl-demo  ","slug":"2018-04-13-yanglei12","published":1,"updated":"2018-06-17T07:42:02.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiiizo5i000uo89kugg3ffcc","content":"<p>前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：</p>\n<p><img src=\"/assets/img/bolang4.gif\" alt=\"WebGL波浪效果\"></p>\n<p>让我们先准备一下前期的WebGL内容,首先让我们来创建一个可以接受参数的着色器，（如果不清楚具体要怎么创建可以参考上一章教程内容哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）<br>接下来，我们需要创建多个点的坐标，所有点在同一行时，只有X坐标是变化的，y是相同的。</p>\n<p>但因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：</p>\n<p><img src=\"/assets/img/yanglei12-1.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>然后你知道了这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//错误</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; style=&quot;width: 700px; height: 500px;&quot;&gt;</span><br><span class=\"line\">//正确的方式</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>首先我们需要先将对应的真实坐标转换成WebGL坐标，因为canvas宽度的一半对应为WebGL的1.0尺寸。所以将真实像素除以宽度的一半就可以得到对应的WebGL尺寸，高度与宽度的处理方式一致。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function webglX (num) &#123;</span><br><span class=\"line\">    return num/(width/2);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function webglY (num) &#123;</span><br><span class=\"line\">    return num/(height/2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了点，那么我们就可以使用先前讲过的缓存区开始批量绘制点了。（如果不清楚具体如何使用缓存区绘制，也可以点击上一章哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）。</p>\n<p>接下来我们要让他动起来，怎么动起来呢？思路是我们可以在不停的重绘，并且将点进行轻微位移即可达到效果，定时执行函数可以使用<strong><em>setInterval</em></strong>或<strong><em>setTimeout</em></strong>。但此2个函数性能上有很大问题，并且也无法完美的匹配浏览器的刷新频率。</p>\n<p>在这里我跟大家介绍一个新函数<strong><em>requestAnimationFrame</em></strong></p>\n<p>requestAnimationFrame是为了提高js动画性能而诞生的神器。下面我们简单来介绍一下这个函数为何被誉为神器。</p>\n<blockquote>\n<ol>\n<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，也就是没s刷新60次。因与浏览器刷新频率一样所以不会出现看似卡顿的情况出现。</li>\n<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>\n<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>\n</ol>\n</blockquote>\n<p>具体的内容以后有机会可以单独详细来介绍此函数功能。</p>\n<p>接下来让我们来绘制一个变化的函数,变化值从0开始，requestAnimationFrame内容入参为循环执行的函数名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 0;</span><br><span class=\"line\">function render() &#123;</span><br><span class=\"line\">    requestAnimationFrame(render);</span><br><span class=\"line\">    num = num - 1;</span><br><span class=\"line\">    var data = createPoints(num);</span><br><span class=\"line\">    setPoints(data, 1000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要将之前绘制点的部分功能函数提取到单独的一个函数中，方便动画循环调用时使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setPoints(data, num) &#123;</span><br><span class=\"line\">    var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">    if(!vertexBuffer) &#123;</span><br><span class=\"line\">        log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">    var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">    gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">    gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">    gl.drawArrays(gl.POINTS, 0 , num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来也就是最重要的，我们需要每次都变更对应点的坐标位置，因我们要使用波浪效果，所以采用正弦函数来实现，首先让所有的点都按照每次变更10度的浮动，并且因为是上下移动，我们只需要变更y轴的坐标即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var width = 700;</span><br><span class=\"line\">var height = 500;</span><br><span class=\"line\">function createPoints(gap) &#123;</span><br><span class=\"line\">    var max = 10</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var n = 100;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var x = webglX(-(width/2) + i*20);</span><br><span class=\"line\">            var y = webglY((height/2)  - j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Float32Array(arr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正弦函数Math.sin传入的值不是角度，而是弧度，我们需要通过下面的函数把角度转化为弧度，函数如下：（如果您不知道弧度与角度的关系，建议自行查询）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function numToDeg(num) &#123;</span><br><span class=\"line\">    return Math.PI*num / 180;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们为此函数中x与y的值进行一下操作。</p>\n<p>1.为保证所有的点肯定全部覆盖屏幕，我们将每个点的间距调整按照整个canvas宽度超过500的尺寸来平均分，整个坐标系向做便宜200，也就是右边还存在300的富于空间，这样即使有错开位移也不会让屏幕露出空白。接下来，为了让上面的点波动比下面的点大，让我们来设置了一个最大倍数，并且将行数与此倍数关联，这样就会使动画上下浮动不一样了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure></p>\n<p>我们达到了横向<br><img src=\"/assets/img/bolang1.gif\" alt=\"WebGL波浪效果\"></p>\n<p>接下来我们在角度便宜中添加上x轴的影响力。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (i-j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure></p>\n<p>让我们看看效果，波动开始有偏差了<br><img src=\"/assets/img/bolang2.gif\" alt=\"WebGL波浪效果\"></p>\n<p>效果按照我们预期的方向前进了，接下来我们扩大x轴的影响,这个个人可以一点一点尝试，我们直接扩大到5倍</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (i*5-j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/bolang3.gif\" alt=\"WebGL波浪效果\"></p>\n<p>看样子动画效果已经基本达到了效果，接下来让我们把上面的点变小，下面的点变大。产生前后的视觉差。<br>如何让渲染的点尺寸不同呢？没错我们也可以使用缓存区来操作。<br>对创建点的函数进行改造：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function createPoints(gap) &#123;</span><br><span class=\"line\">    //波动最大幅度 10px;</span><br><span class=\"line\">    var max = 10</span><br><span class=\"line\">    var n = 100;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var size = [];</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var deg = (i*7-j*20+gap);</span><br><span class=\"line\">            var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">            var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">            size.push((4-j/4));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        positions: new Float32Array(arr),</span><br><span class=\"line\">        size: new Float32Array(size),</span><br><span class=\"line\">        num: m * n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们把点与对应的坐标匹配一下，并且把点的数量动态化,让我们在使用缓存区来把size动态批量化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setSize(sizes, n) &#123;</span><br><span class=\"line\">    var sizeBuffer = gl.createBuffer();</span><br><span class=\"line\">    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);</span><br><span class=\"line\">    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);</span><br><span class=\"line\">    var a_pointsize = gl.getAttribLocation(gl.program, &apos;size&apos;);</span><br><span class=\"line\">    gl.vertexAttribPointer(a_pointsize, 1, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">    gl.enableVertexAttribArray(a_pointsize);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>记得着色器上要声明一个接收的参数哦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute float size;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们在render函数中可以直接使用其函数进行重绘了<br><img src=\"/assets/img/bolang4.gif\" alt=\"WebGL波浪效果\"><br>我们已经绘制出来了最终效果，本着开源的原则，完整代码链接如下：</p>\n<p><a href=\"https://github.com/jdf2e/webgl-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/jdf2e/webgl-demo</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>前文已经大概讲解了一些基础知识，涵盖了WebGL创建，着色器，着色器编程以及缓存区等知识，一些简单的点面效果即可以基于此来完成，接下来让我们绘制一下如下的效果：</p>\n<p><img src=\"/assets/img/bolang4.gif\" alt=\"WebGL波浪效果\"></p>\n<p>让我们先准备一下前期的WebGL内容,首先让我们来创建一个可以接受参数的着色器，（如果不清楚具体要怎么创建可以参考上一章教程内容哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）<br>接下来，我们需要创建多个点的坐标，所有点在同一行时，只有X坐标是变化的，y是相同的。</p>\n<p>但因为WebGL的坐标系与实际页面中的坐标系是不同的，如下图，普通canvas坐标系与正常的浏览器像素值相同，但WebGL中的坐标系是以整个WebGL中心点为（0.0，0.0），而且坐标的精确度为小数点后一位。坐标系对比如下图所示：</p>\n<p><img src=\"/assets/img/yanglei12-1.jpg\" alt=\"WebGL坐标系与普通canvas坐标系\"></p>\n<p>然后你知道了这个依旧会绘制出超级模糊的图像，那是因为整个WebGL的尺寸是与canvas宽度与高度相关连的，并且canvas的宽度与高度如果用css来设置的话，会被默认成100×100，也就意味着，你绘制出来的图形是把100×100的图形拉伸到当前canvas的尺寸中。所以正确的设置canvas的方式应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//错误</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; style=&quot;width: 700px; height: 500px;&quot;&gt;</span><br><span class=\"line\">//正确的方式</span><br><span class=\"line\">&lt;canvas id=&quot;glcanvas&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>首先我们需要先将对应的真实坐标转换成WebGL坐标，因为canvas宽度的一半对应为WebGL的1.0尺寸。所以将真实像素除以宽度的一半就可以得到对应的WebGL尺寸，高度与宽度的处理方式一致。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function webglX (num) &#123;</span><br><span class=\"line\">    return num/(width/2);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function webglY (num) &#123;</span><br><span class=\"line\">    return num/(height/2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了点，那么我们就可以使用先前讲过的缓存区开始批量绘制点了。（如果不清楚具体如何使用缓存区绘制，也可以点击上一章哦，<a target=\"_blank\" href=\"/yanglei/2018/04/14/yanglei11.html\">点击跳转</a>）。</p>\n<p>接下来我们要让他动起来，怎么动起来呢？思路是我们可以在不停的重绘，并且将点进行轻微位移即可达到效果，定时执行函数可以使用<strong><em>setInterval</em></strong>或<strong><em>setTimeout</em></strong>。但此2个函数性能上有很大问题，并且也无法完美的匹配浏览器的刷新频率。</p>\n<p>在这里我跟大家介绍一个新函数<strong><em>requestAnimationFrame</em></strong></p>\n<p>requestAnimationFrame是为了提高js动画性能而诞生的神器。下面我们简单来介绍一下这个函数为何被誉为神器。</p>\n<blockquote>\n<ol>\n<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，也就是没s刷新60次。因与浏览器刷新频率一样所以不会出现看似卡顿的情况出现。</li>\n<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>\n<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>\n</ol>\n</blockquote>\n<p>具体的内容以后有机会可以单独详细来介绍此函数功能。</p>\n<p>接下来让我们来绘制一个变化的函数,变化值从0开始，requestAnimationFrame内容入参为循环执行的函数名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 0;</span><br><span class=\"line\">function render() &#123;</span><br><span class=\"line\">    requestAnimationFrame(render);</span><br><span class=\"line\">    num = num - 1;</span><br><span class=\"line\">    var data = createPoints(num);</span><br><span class=\"line\">    setPoints(data, 1000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要将之前绘制点的部分功能函数提取到单独的一个函数中，方便动画循环调用时使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setPoints(data, num) &#123;</span><br><span class=\"line\">    var vertexBuffer = gl.createBuffer();</span><br><span class=\"line\">    if(!vertexBuffer) &#123;</span><br><span class=\"line\">        log(&apos;创建缓存区失败。&apos;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class=\"line\">    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);</span><br><span class=\"line\">    var a_position = gl.getAttribLocation(gl.program, &apos;a_p&apos;);</span><br><span class=\"line\">    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">    gl.enableVertexAttribArray(a_position);</span><br><span class=\"line\">    gl.clearColor(0.0,0.0,0.0,1.0);</span><br><span class=\"line\">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class=\"line\">    gl.drawArrays(gl.POINTS, 0 , num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来也就是最重要的，我们需要每次都变更对应点的坐标位置，因我们要使用波浪效果，所以采用正弦函数来实现，首先让所有的点都按照每次变更10度的浮动，并且因为是上下移动，我们只需要变更y轴的坐标即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var width = 700;</span><br><span class=\"line\">var height = 500;</span><br><span class=\"line\">function createPoints(gap) &#123;</span><br><span class=\"line\">    var max = 10</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var n = 100;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var x = webglX(-(width/2) + i*20);</span><br><span class=\"line\">            var y = webglY((height/2)  - j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new Float32Array(arr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正弦函数Math.sin传入的值不是角度，而是弧度，我们需要通过下面的函数把角度转化为弧度，函数如下：（如果您不知道弧度与角度的关系，建议自行查询）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function numToDeg(num) &#123;</span><br><span class=\"line\">    return Math.PI*num / 180;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们为此函数中x与y的值进行一下操作。</p>\n<p>1.为保证所有的点肯定全部覆盖屏幕，我们将每个点的间距调整按照整个canvas宽度超过500的尺寸来平均分，整个坐标系向做便宜200，也就是右边还存在300的富于空间，这样即使有错开位移也不会让屏幕露出空白。接下来，为了让上面的点波动比下面的点大，让我们来设置了一个最大倍数，并且将行数与此倍数关联，这样就会使动画上下浮动不一样了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure></p>\n<p>我们达到了横向<br><img src=\"/assets/img/bolang1.gif\" alt=\"WebGL波浪效果\"></p>\n<p>接下来我们在角度便宜中添加上x轴的影响力。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (i-j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure></p>\n<p>让我们看看效果，波动开始有偏差了<br><img src=\"/assets/img/bolang2.gif\" alt=\"WebGL波浪效果\"></p>\n<p>效果按照我们预期的方向前进了，接下来我们扩大x轴的影响,这个个人可以一点一点尝试，我们直接扩大到5倍</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deg = (i*5-j*20+gap);</span><br><span class=\"line\">var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/bolang3.gif\" alt=\"WebGL波浪效果\"></p>\n<p>看样子动画效果已经基本达到了效果，接下来让我们把上面的点变小，下面的点变大。产生前后的视觉差。<br>如何让渲染的点尺寸不同呢？没错我们也可以使用缓存区来操作。<br>对创建点的函数进行改造：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function createPoints(gap) &#123;</span><br><span class=\"line\">    //波动最大幅度 10px;</span><br><span class=\"line\">    var max = 10</span><br><span class=\"line\">    var n = 100;</span><br><span class=\"line\">    var m = 10;</span><br><span class=\"line\">    var arr = [];</span><br><span class=\"line\">    var size = [];</span><br><span class=\"line\">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        for(var j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">            var deg = (i*7-j*20+gap);</span><br><span class=\"line\">            var x = webglX(-(width/2)-200+i*((width+500)/n)+j*20);</span><br><span class=\"line\">            var y = webglY(-(height/2)+Math.sin(numToDeg(deg))*(max+j*4) + j*20);</span><br><span class=\"line\">            var z = -1;</span><br><span class=\"line\">            var item = [x, y, z];</span><br><span class=\"line\">            arr = arr.concat(item);</span><br><span class=\"line\">            size.push((4-j/4));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        positions: new Float32Array(arr),</span><br><span class=\"line\">        size: new Float32Array(size),</span><br><span class=\"line\">        num: m * n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们把点与对应的坐标匹配一下，并且把点的数量动态化,让我们在使用缓存区来把size动态批量化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setSize(sizes, n) &#123;</span><br><span class=\"line\">    var sizeBuffer = gl.createBuffer();</span><br><span class=\"line\">    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);</span><br><span class=\"line\">    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);</span><br><span class=\"line\">    var a_pointsize = gl.getAttribLocation(gl.program, &apos;size&apos;);</span><br><span class=\"line\">    gl.vertexAttribPointer(a_pointsize, 1, gl.FLOAT, false, 0, 0);</span><br><span class=\"line\">    gl.enableVertexAttribArray(a_pointsize);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>记得着色器上要声明一个接收的参数哦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute float size;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们在render函数中可以直接使用其函数进行重绘了<br><img src=\"/assets/img/bolang4.gif\" alt=\"WebGL波浪效果\"><br>我们已经绘制出来了最终效果，本着开源的原则，完整代码链接如下：</p>\n<p><a href=\"https://github.com/jdf2e/webgl-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/jdf2e/webgl-demo</a>  </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjiiizo510007o89kta92y2ps","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo59000eo89ktuq67iu5"},{"post_id":"cjiiizo4r0000o89ksuvx84oc","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5c000jo89kdfbyhfq6"},{"post_id":"cjiiizo520008o89kurtz1dng","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5e000mo89k955y7nlq"},{"post_id":"cjiiizo55000co89k6yj9zxln","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5g000po89k6imy57k3"},{"post_id":"cjiiizo4v0002o89kwth32mfm","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5h000so89ks8ayg8z6"},{"post_id":"cjiiizo58000do89kjjj686nm","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5j000vo89k6qa43goc"},{"post_id":"cjiiizo5b000io89kcn03xhy9","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5k000xo89k1rljq193"},{"post_id":"cjiiizo500006o89klsfyb41d","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5k0010o89kmblw7vav"},{"post_id":"cjiiizo5d000lo89khz2m6wxi","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5l0012o89ka1e5elq9"},{"post_id":"cjiiizo5f000oo89kwdils2fj","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5l0015o89k240c93z4"},{"post_id":"cjiiizo5g000ro89k5ggd0ysu","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5m0017o89krk1ggaab"},{"post_id":"cjiiizo5i000uo89kugg3ffcc","category_id":"cjiiizo4y0004o89kuak8b3v9","_id":"cjiiizo5m0019o89kxannfa1i"}],"PostTag":[{"post_id":"cjiiizo4r0000o89ksuvx84oc","tag_id":"cjiiizo4z0005o89km8cse38t","_id":"cjiiizo55000bo89kjotyyula"},{"post_id":"cjiiizo4v0002o89kwth32mfm","tag_id":"cjiiizo4z0005o89km8cse38t","_id":"cjiiizo5a000ho89kg4j0lt2k"},{"post_id":"cjiiizo58000do89kjjj686nm","tag_id":"cjiiizo4z0005o89km8cse38t","_id":"cjiiizo5c000ko89k7qqbogl6"},{"post_id":"cjiiizo500006o89klsfyb41d","tag_id":"cjiiizo5a000go89kceegz2ua","_id":"cjiiizo5g000qo89kztqd378b"},{"post_id":"cjiiizo510007o89kta92y2ps","tag_id":"cjiiizo5e000no89kzyye3s93","_id":"cjiiizo5k000wo89k2rfv0jfw"},{"post_id":"cjiiizo5g000ro89k5ggd0ysu","tag_id":"cjiiizo5e000no89kzyye3s93","_id":"cjiiizo5k000yo89k5hvcmdi6"},{"post_id":"cjiiizo5i000uo89kugg3ffcc","tag_id":"cjiiizo5e000no89kzyye3s93","_id":"cjiiizo5l0011o89kizj8i3ge"},{"post_id":"cjiiizo520008o89kurtz1dng","tag_id":"cjiiizo5h000to89kf85k7irk","_id":"cjiiizo5l0013o89kvu495p5x"},{"post_id":"cjiiizo55000co89k6yj9zxln","tag_id":"cjiiizo5h000to89kf85k7irk","_id":"cjiiizo5m0016o89kgfu5jeaz"},{"post_id":"cjiiizo5b000io89kcn03xhy9","tag_id":"cjiiizo5h000to89kf85k7irk","_id":"cjiiizo5n001ao89kkfailcnx"},{"post_id":"cjiiizo5d000lo89khz2m6wxi","tag_id":"cjiiizo5h000to89kf85k7irk","_id":"cjiiizo5n001co89kzxq2s34s"},{"post_id":"cjiiizo5f000oo89kwdils2fj","tag_id":"cjiiizo5h000to89kf85k7irk","_id":"cjiiizo5n001do89krp0p26cs"}],"Tag":[{"name":"react","_id":"cjiiizo4z0005o89km8cse38t"},{"name":"nodeJS","_id":"cjiiizo5a000go89kceegz2ua"},{"name":"js","_id":"cjiiizo5e000no89kzyye3s93"},{"name":"WebGL","_id":"cjiiizo5h000to89kf85k7irk"}]}}